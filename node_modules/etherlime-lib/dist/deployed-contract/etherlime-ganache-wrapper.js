"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const etherlime_utils_1 = require("etherlime-utils");
const deployed_contract_wrapper_1 = require("./deployed-contract-wrapper");
const etherlime_logger_1 = require("etherlime-logger");
const etherlime_config_1 = require("etherlime-config");
const ethers_1 = require("ethers");
class EtherlimeGanacheWrapper extends deployed_contract_wrapper_1.default {
    constructor(contract, contractAddress, signer, provider) {
        super(contract, contractAddress, signer, provider);
        this.instances = new Array();
        this.instancesMap = {};
        for (const acc of etherlime_config_1.ganacheSetupConfig.accounts) {
            const accSigner = new ethers_1.Wallet(acc.secretKey, provider);
            const accContract = new ethers_1.Contract(contractAddress, contract.abi, accSigner);
            this.instances.push(accContract);
            this.instancesMap[accSigner.address] = accContract;
        }
    }
    from(addressOrSignerOrIndex) {
        if (typeof addressOrSignerOrIndex === 'number' && Number.isInteger(addressOrSignerOrIndex)) {
            return this.instances[addressOrSignerOrIndex];
        }
        if (typeof addressOrSignerOrIndex === 'string' || addressOrSignerOrIndex instanceof String) {
            return this.instancesMap[addressOrSignerOrIndex.toString()];
        }
        if (typeof addressOrSignerOrIndex !== 'number' && etherlime_utils_1.isSigner(addressOrSignerOrIndex)) {
            let instance = this.instancesMap[addressOrSignerOrIndex.address];
            if (!instance) {
                return new ethers_1.Contract(this.contractAddress, this._contract.abi, addressOrSignerOrIndex);
            }
            return this.instancesMap[addressOrSignerOrIndex.address];
        }
        if (typeof addressOrSignerOrIndex !== 'number' && etherlime_utils_1.isSigner(addressOrSignerOrIndex.signer)) {
            let instance = this.instancesMap[addressOrSignerOrIndex.signer.address];
            if (!instance) {
                return new ethers_1.Contract(this.contractAddress, this._contract.abi, addressOrSignerOrIndex.signer);
            }
            return this.instancesMap[addressOrSignerOrIndex.signer.address];
        }
        throw new Error('Unrecognized input parameter. It should be index, address or signer instance');
    }
    verboseWaitForTransaction(transaction, transactionLabel) {
        return __awaiter(this, void 0, void 0, function* () {
            let labelPart = (transactionLabel) ? `labeled ${etherlime_utils_1.colors.colorName(transactionLabel)} ` : '';
            etherlime_logger_1.logger.log(`Waiting for transaction ${labelPart}to be included in a block and mined: ${etherlime_utils_1.colors.colorTransactionHash(transaction.hash)}`);
            yield this.provider.send('evm_mine', []);
            const transactionReceipt = yield transaction.wait();
            yield this._postValidateTransaction(transaction, transactionReceipt);
            const actionLabel = (transactionLabel) ? transactionLabel : this.constructor.name;
            yield this._logAction(this.constructor.name, actionLabel, transaction.hash, 0, transaction.gasPrice.toString(), transactionReceipt.gasUsed.toString(), 'Successfully Waited For Transaction');
            return transactionReceipt;
        });
    }
}
exports.default = EtherlimeGanacheWrapper;
//# sourceMappingURL=etherlime-ganache-wrapper.js.map