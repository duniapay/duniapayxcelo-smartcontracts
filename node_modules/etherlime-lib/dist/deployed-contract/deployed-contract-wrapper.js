"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ethers_1 = require("ethers");
const etherlime_utils_1 = require("etherlime-utils");
const etherlime_logger_1 = require("etherlime-logger");
class DeployedContractWrapper {
    constructor(contract, contractAddress, signer, provider) {
        this._validateInput(contract, contractAddress, signer);
        this.contractAddress = contractAddress;
        this.signer = signer;
        this.provider = provider;
        this._contract = contract;
        this.contract = new ethers_1.Contract(contractAddress, contract.abi, signer);
        Object.assign(this, this.contract.functions);
        this.interface = this.contract.interface;
        this.estimate = this.contract.estimate;
        this.functions = this.contract.functions;
        this.filters = this.contract.filters;
        this.utils = this._generateUtils(provider);
    }
    _generateUtils(provider) {
        return {
            getBalance: () => provider.getBalance(this.contractAddress)
        };
    }
    _validateInput(contract, contractAddress, signer) {
        if (!(etherlime_utils_1.isSigner(signer))) {
            throw new Error('Passed signer is not a valid signer instance of ethers Wallet');
        }
        if (!(etherlime_utils_1.isAddress(contractAddress))) {
            throw new Error(`Passed contract address (${contractAddress}) is not valid address`);
        }
        if (!(etherlime_utils_1.isValidContract(contract))) {
            throw new Error(`Passed contract is not a valid contract object. It needs to have bytecode, abi and contractName properties`);
        }
    }
    /**
     *
     * Use this method to wait for transaction and print verbose logs
     *
     * @param {*} transactionHash The transaction hash you are waiting for
     * @param {*} transactionLabel [Optional] A human readable label to help you differentiate you transaction
     */
    verboseWaitForTransaction(transaction, transactionLabel) {
        return __awaiter(this, void 0, void 0, function* () {
            let labelPart = (transactionLabel) ? `labeled ${etherlime_utils_1.colors.colorName(transactionLabel)} ` : '';
            etherlime_logger_1.logger.log(`Waiting for transaction ${labelPart}to be included in a block and mined: ${etherlime_utils_1.colors.colorTransactionHash(transaction.hash)}`);
            const transactionReceipt = yield transaction.wait();
            yield this._postValidateTransaction(transaction, transactionReceipt);
            const actionLabel = (transactionLabel) ? transactionLabel : this.constructor.name;
            yield this._logAction(this.constructor.name, actionLabel, transaction.hash, 0, transaction.gasPrice.toString(), transactionReceipt.gasUsed.toString(), 'Successfully Waited For Transaction');
            return transactionReceipt;
        });
    }
    _postValidateTransaction(transaction, transactionReceipt) {
        return __awaiter(this, void 0, void 0, function* () {
            if (transactionReceipt.status === 0) {
                yield this._logAction(this.constructor.name, this._contract.contractName, transaction.hash, 1, transaction.gasPrice.toString(), transactionReceipt.gasUsed.toString(), 'Transaction failed');
                throw new Error(`Transaction ${etherlime_utils_1.colors.colorTransactionHash(transactionReceipt.transactionHash)} ${etherlime_utils_1.colors.colorFailure('failed')}. Please check etherscan for better reason explanation.`);
            }
            return transactionReceipt;
        });
    }
    /**
     *
     * Override this for custom logging functionality
     *
     * @param {*} deployerType type of deployer
     * @param {*} nameOrLabel name of the contract or label of the transaction
     * @param {*} transactionHash transaction hash if available
     * @param {*} status 0 - success, 1 - failure
     * @param {*} gasPrice the gas price param that was used by this transaction
     * @param {*} gasUsed the gas used by this transaction
     * @param {*} result arbitrary result text
     */
    _logAction(deployerType, nameOrLabel, transactionHash, status, gasPrice, gasUsed, result) {
        return __awaiter(this, void 0, void 0, function* () {
            const network = yield this.provider.getNetwork();
            etherlime_logger_1.logsStore.logAction(deployerType, nameOrLabel, transactionHash, status, gasPrice, gasUsed, network.chainId, result);
        });
    }
}
exports.default = DeployedContractWrapper;
//# sourceMappingURL=deployed-contract-wrapper.js.map