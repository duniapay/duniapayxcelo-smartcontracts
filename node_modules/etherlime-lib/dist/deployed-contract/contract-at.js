"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ethers_1 = require("ethers");
const etherlime_config_1 = require("etherlime-config");
const etherlime_utils_1 = require("etherlime-utils");
const deployed_contract_wrapper_1 = require("./deployed-contract-wrapper");
const etherlime_ganache_wrapper_1 = require("./etherlime-ganache-wrapper");
/**
 *
 * @param {*} contract
 * @param {*} contractAddress
 * @param {*} signer The signer to connect this contract to
 * @param {*} providerOrPort Either provider to connect a normal Deployed Contract Wrapper or the port that the etherlime ganache is run on. Defaults to 8545
 */
const contractAt = (contract, contractAddress, signer, providerOrPort) => __awaiter(this, void 0, void 0, function* () {
    if (typeof providerOrPort !== 'number' && etherlime_utils_1.isProvider(providerOrPort)) {
        if (!signer || !(etherlime_utils_1.isSigner(signer))) {
            throw new Error(`Incorrect signer supplied - ${JSON.stringify(signer)}`);
        }
        if (!signer.provider) {
            throw new Error(`Passed signer is not connected to any provider.`);
        }
        return new deployed_contract_wrapper_1.default(contract, contractAddress, signer, providerOrPort);
    }
    if (!providerOrPort) {
        providerOrPort = 8545;
    }
    if (typeof providerOrPort === 'number' && Number.isInteger(providerOrPort)) {
        const provider = new ethers_1.providers.JsonRpcProvider(`http://localhost:${providerOrPort}`);
        if (etherlime_utils_1.isSigner(signer)) {
            if (!signer.provider) {
                throw new Error(`Passed signer is not connected to current provider ${providerOrPort}`);
            }
            return new etherlime_ganache_wrapper_1.default(contract, contractAddress, signer, provider);
        }
        let signerInstance = new ethers_1.Wallet(etherlime_config_1.ganacheSetupConfig.accounts[0].secretKey, provider);
        return new etherlime_ganache_wrapper_1.default(contract, contractAddress, signerInstance, provider);
    }
    throw new Error('You have supplied invalid value for provider or port argument');
});
exports.default = contractAt;
//# sourceMappingURL=contract-at.js.map