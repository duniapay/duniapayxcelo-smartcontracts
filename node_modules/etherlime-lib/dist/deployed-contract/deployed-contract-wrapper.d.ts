import { Wallet, Contract, ContractFunction, EventFilter, providers, utils } from 'ethers';
import { CompiledContract, Generic } from '../types/types';
declare class DeployedContractWrapper {
    /**
     *
     * Object representing deployed contract allowing user to interact with deployed contracts
     *
     * @param {*} contract The deployed contract descriptor
     * @param {*} contractAddress The address of the deployed contract
     * @param {*} signer The signer that has deployed this contract
     * @param {*} provider ethers provider
     */
    contract: Contract;
    contractAddress: string;
    signer: Wallet;
    provider: providers.JsonRpcProvider;
    _contract: CompiledContract;
    interface: utils.Interface;
    estimate: Generic<(...params: Array<any>) => Promise<utils.BigNumber>>;
    functions: Generic<ContractFunction>;
    filters: Generic<(...params: Array<any>) => EventFilter>;
    utils: Generic<(provider: providers.JsonRpcProvider) => {}>;
    constructor(contract: CompiledContract, contractAddress: string, signer?: Wallet, provider?: providers.JsonRpcProvider);
    private _generateUtils;
    private _validateInput;
    /**
     *
     * Use this method to wait for transaction and print verbose logs
     *
     * @param {*} transactionHash The transaction hash you are waiting for
     * @param {*} transactionLabel [Optional] A human readable label to help you differentiate you transaction
     */
    verboseWaitForTransaction(transaction: providers.TransactionResponse, transactionLabel: string): Promise<providers.TransactionReceipt>;
    protected _postValidateTransaction(transaction: providers.TransactionResponse, transactionReceipt: providers.TransactionReceipt): Promise<providers.TransactionReceipt>;
    /**
     *
     * Override this for custom logging functionality
     *
     * @param {*} deployerType type of deployer
     * @param {*} nameOrLabel name of the contract or label of the transaction
     * @param {*} transactionHash transaction hash if available
     * @param {*} status 0 - success, 1 - failure
     * @param {*} gasPrice the gas price param that was used by this transaction
     * @param {*} gasUsed the gas used by this transaction
     * @param {*} result arbitrary result text
     */
    protected _logAction(deployerType: string, nameOrLabel: string, transactionHash: string, status: number, gasPrice: string, gasUsed: string, result: string): Promise<void>;
}
export default DeployedContractWrapper;
