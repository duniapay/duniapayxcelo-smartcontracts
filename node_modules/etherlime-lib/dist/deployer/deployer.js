"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ethers_1 = require("ethers");
const etherlime_utils_1 = require("etherlime-utils");
const deployed_contract_wrapper_1 = require("./../deployed-contract/deployed-contract-wrapper");
const etherlime_logger_1 = require("etherlime-logger");
class Deployer {
    constructor(signer, provider, defaultOverrides) {
        this._validateInput(signer);
        this.signer = signer;
        this.provider = provider;
        this.signer = this.signer.connect(this.provider);
        this.defaultOverrides = defaultOverrides;
        etherlime_logger_1.logsStore.initHistoryRecord();
    }
    setSigner(signer) {
        this._validateInput(signer);
        this.signer = signer;
        this.signer = this.signer.connect(this.provider);
    }
    setProvider(provider) {
        this.provider = provider;
        this.signer = this.signer.connect(this.provider);
    }
    setDefaultOverrides(defaultOverrides) {
        this.defaultOverrides = defaultOverrides;
    }
    setVerifierApiKey(etherscanApiKey) {
        if (!this.defaultOverrides) {
            this.defaultOverrides = {};
        }
        this.defaultOverrides.etherscanApiKey = etherscanApiKey;
    }
    _validateInput(signer) {
        if (!(etherlime_utils_1.isSigner(signer))) {
            throw new Error('Passed signer is not valid signer instance of ethers Wallet');
        }
    }
    /**
     *
     * Use this function to deploy a contract.
     *
     * @return DeploymentResult object
     *
     * @param {*} contract the contract object to be deployed. Must have at least abi and bytecode fields. For now use the .json file generated from etherlime compile
     */
    deploy(contract, libraries, ...args) {
        return __awaiter(this, void 0, void 0, function* () {
            const deploymentArguments = Array.prototype.slice.call(args);
            const { contractCopy, transaction, transactionReceipt, deploymentResult } = yield this._prepareAndDeployTransaction(contract, libraries, deploymentArguments);
            yield this._logAction(this.constructor.name, contractCopy.contractName, transaction.hash, 0, transaction.gasPrice.toString(), transactionReceipt.gasUsed.toString(), deploymentResult.contractAddress, deploymentResult._contract.compiler ? deploymentResult._contract.compiler.version : null, false);
            return deploymentResult;
        });
    }
    deployAndVerify(contract, libraries, ...args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.defaultOverrides || !this.defaultOverrides.etherscanApiKey) {
                throw new Error('Please provide Etherscan API key!');
            }
            const deploymentArguments = Array.prototype.slice.call(args);
            const { contractCopy, transaction, transactionReceipt, deploymentResult } = yield this._prepareAndDeployTransaction(contract, libraries, deploymentArguments);
            const verification = yield Verifier.verifySmartContract(deploymentResult, deploymentArguments, libraries, this.defaultOverrides);
            yield this._logAction(this.constructor.name, contractCopy.contractName, transaction.hash, 0, transaction.gasPrice.toString(), transactionReceipt.gasUsed.toString(), deploymentResult.contractAddress, deploymentResult._contract.compiler ? deploymentResult._contract.compiler.version : null, verification);
            return deploymentResult;
        });
    }
    _prepareAndDeployTransaction(contract, libraries, deploymentArguments) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._preValidateArguments(contract, deploymentArguments);
            let contractCopy = JSON.parse(JSON.stringify(contract));
            contractCopy.bytecode = yield this._prepareBytecode(libraries, contractCopy.bytecode);
            let deployTransaction = yield this._prepareDeployTransaction(contractCopy, deploymentArguments);
            deployTransaction = yield this._overrideDeployTransactionConfig(deployTransaction);
            const transaction = yield this._sendDeployTransaction(deployTransaction);
            const transactionReceipt = yield this._waitForDeployTransaction(transaction);
            yield this._postValidateTransaction(contractCopy, transaction, transactionReceipt);
            const deploymentResult = yield this._generateDeploymentResult(contractCopy, transaction, transactionReceipt);
            return { contractCopy, transaction, transactionReceipt, deploymentResult };
        });
    }
    /**
     *
     * Override for custom pre-send validation
     *
     * @param {*} contract the contract to be deployed
     * @param {*} deploymentArguments the deployment arguments
     */
    _preValidateArguments(contract, deploymentArguments) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(etherlime_utils_1.isValidContract(contract))) {
                yield this._logAction(this.constructor.name, contract ? contract.contractName : 'No contract name', '', 1, '-', '-', 'Invalid contract object', '-', false);
                throw new Error(`Passed contract is not a valid contract object. It needs to have bytecode, abi and contractName properties`);
            }
            if (!etherlime_utils_1.isValidBytecode(contract.bytecode)) {
                throw new Error(`The bytecode is invalid. It should be of type string with length bigger than 0`);
            }
            const deployContractStart = `\nDeploying contract: ${etherlime_utils_1.colors.colorName(contract.contractName)}`;
            const argumentsEnd = (deploymentArguments.length === 0) ? '' : ` with parameters: ${etherlime_utils_1.colors.colorParams(deploymentArguments)}`;
            etherlime_logger_1.logger.log(`${deployContractStart}${argumentsEnd}`);
        });
    }
    /**
     *
     * Override this to include custom logic for deploy transaction generation
     *
     * @param {*} contract the contract to be deployed
     * @param {*} deploymentArguments the arguments to this contract
     */
    _prepareDeployTransaction(contract, deploymentArguments) {
        return __awaiter(this, void 0, void 0, function* () {
            let factory = new ethers_1.ContractFactory(contract.abi, contract.bytecode);
            return factory.getDeployTransaction(...deploymentArguments);
        });
    }
    /**
     *
     * Override this for custom deploy transaction configuration
     *
     * @param {*} deployTransaction the transaction that is to be overridden
     */
    _overrideDeployTransactionConfig(deployTransaction) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.defaultOverrides === undefined) {
                return deployTransaction;
            }
            if (this.defaultOverrides.gasPrice > 0) {
                deployTransaction.gasPrice = this.defaultOverrides.gasPrice;
            }
            if (this.defaultOverrides.gasLimit > 0) {
                deployTransaction.gasLimit = this.defaultOverrides.gasLimit;
            }
            if (this.defaultOverrides.chainId !== undefined) {
                deployTransaction.chainId = this.defaultOverrides.chainId;
            }
            return deployTransaction;
        });
    }
    /**
     *
     * Override this to include custom logic for sending the deploy transaction
     *
     * @param {*} deployTransaction the transaction that is to be sent
     */
    _sendDeployTransaction(deployTransaction) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.signer.sendTransaction(deployTransaction);
        });
    }
    /**
     *
     * Override this to include custom logic for waiting for deployed transaction. For example you could trigger mined block for testrpc/ganache-cli
     *
     * @param {*} transaction The sent transaction object to be waited for
     */
    _waitForDeployTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            etherlime_logger_1.logger.log(`Waiting for transaction to be included in a block and mined: ${etherlime_utils_1.colors.colorTransactionHash(transaction.hash)}`);
            return transaction.wait();
        });
    }
    /**
     *
     * @param {*} contract the contract being deployed
     * @param {*} transaction the transaction object being sent
     * @param {*} transactionReceipt the transaction receipt
     */
    _postValidateTransaction(contract, transaction, transactionReceipt) {
        return __awaiter(this, void 0, void 0, function* () {
            if (transactionReceipt.status === 0) {
                yield this._logAction(this.constructor.name, contract.contractName, transaction.hash, 1, transaction.gasPrice.toString(), transactionReceipt.gasUsed.toString(), 'Transaction failed', '-', false);
                throw new Error(`Transaction ${etherlime_utils_1.colors.colorTransactionHash(transactionReceipt.transactionHash)} ${etherlime_utils_1.colors.colorFailure('failed')}. Please check etherscan for better reason explanation.`);
            }
        });
    }
    /**
     *
     * Override this for custom deployment result objects
     *
     * @param {*} contract the contract that has been deployed
     * @param {*} transaction the transaction object that was sent
     * @param {*} transactionReceipt the transaction receipt
     */
    _generateDeploymentResult(contract, transaction, transactionReceipt) {
        return __awaiter(this, void 0, void 0, function* () {
            etherlime_logger_1.logger.log(`Contract ${etherlime_utils_1.colors.colorName(contract.contractName)} deployed at address: ${etherlime_utils_1.colors.colorAddress(transactionReceipt.contractAddress)}`);
            return new deployed_contract_wrapper_1.default(contract, transactionReceipt.contractAddress, this.signer, this.provider);
        });
    }
    /**
     *
     * Override this for custom logging functionality
     *
     * @param {*} deployerType type of deployer
     * @param {*} nameOrLabel name of the contract or label of the transaction
     * @param {*} transactionHash transaction hash if available
     * @param {*} status 0 - success, 1 - failure
     * @param {*} gasPrice the gas price param that was used by this transaction
     * @param {*} gasUsed the gas used by this transaction
     * @param {*} result arbitrary result text
     */
    _logAction(deployerType, nameOrLabel, transactionHash, status, gasPrice, gasUsed, result, solcVersion, verification) {
        return __awaiter(this, void 0, void 0, function* () {
            const network = yield this.provider.getNetwork();
            etherlime_logger_1.logsStore.logAction(deployerType, nameOrLabel, transactionHash, status, gasPrice, gasUsed, network.chainId, result, solcVersion, verification);
        });
    }
    /**
     *
     * Use this method to wrap an existing address in DeployedContractWrapper. You can use the goodies of the DeployedContractWrapper the same way you can do with a contract you've just deployed.
     *
     * @dev Useful for upgradability
     *
     * @param {*} contract
     * @param {*} contractAddress
     *
     * @return
     */
    wrapDeployedContract(contract, contractAddress) {
        etherlime_logger_1.logger.log(`Wrapping contract ${etherlime_utils_1.colors.colorName(contract.contractName)} at address: ${etherlime_utils_1.colors.colorAddress(contractAddress)}`);
        return new deployed_contract_wrapper_1.default(contract, contractAddress, this.signer, this.provider);
    }
    /**
     *
     * Use this estimate deployment gas cost for given transaction
     *
     * @return the gas it is going to cost
     *
     * @param {*} contract the contract object to be deployed. Must have at least abi and bytecode fields. For now use the .json file generated from etherlime compile. Add the deployment params as comma separated values
     */
    estimateGas(contract, libraries, ...args) {
        return __awaiter(this, void 0, void 0, function* () {
            const deploymentArguments = Array.prototype.slice.call(args);
            yield this._preValidateArguments(contract, deploymentArguments);
            let contractCopy = JSON.parse(JSON.stringify(contract));
            contractCopy.bytecode = yield this._prepareBytecode(libraries, contractCopy.bytecode);
            let deployTransaction = yield this._prepareDeployTransaction(contractCopy, deploymentArguments);
            const gasBN = yield this._estimateTransactionGas(deployTransaction);
            return gasBN.toString();
        });
    }
    _estimateTransactionGas(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.provider.estimateGas(transaction);
        });
    }
    /**
     *
     * Link a library or number of libraries to a contract
     *
     * @param {*} libraries The libraries which will be linked to the contract
     * @param {*} bytecode The contract's bytecode which be used for linking
     */
    _prepareBytecode(libraries, bytecode) {
        return __awaiter(this, void 0, void 0, function* () {
            if (etherlime_utils_1.isValidLibrary(libraries)) {
                return yield etherlime_utils_1.linkLibrary(libraries, bytecode);
            }
            return bytecode;
        });
    }
}
exports.default = Deployer;
//# sourceMappingURL=deployer.js.map