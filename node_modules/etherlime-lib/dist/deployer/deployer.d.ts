import { Wallet, utils, providers } from 'ethers';
import DeployedContractWrapper from './../deployed-contract/deployed-contract-wrapper';
import { TxParams, CompiledContract, Generic } from './../types/types';
declare class Deployer {
    /**
     *
     * Instantiates new deployer. You probably should not use this class directly but use something inheriting this
     *
     * @param {*} signer ethers.Wallet instance
     * @param {*} provider ethers.provider instance
     * @param {*} defaultOverrides [Optional] default deployment overrides
     */
    signer: Wallet;
    provider: providers.JsonRpcProvider | providers.Web3Provider;
    defaultOverrides: TxParams;
    constructor(signer: Wallet, provider: providers.JsonRpcProvider | providers.Web3Provider, defaultOverrides?: TxParams);
    setSigner(signer: Wallet): void;
    setProvider(provider: providers.JsonRpcProvider): void;
    setDefaultOverrides(defaultOverrides: TxParams): void;
    setVerifierApiKey(etherscanApiKey: string): void;
    private _validateInput;
    /**
     *
     * Use this function to deploy a contract.
     *
     * @return DeploymentResult object
     *
     * @param {*} contract the contract object to be deployed. Must have at least abi and bytecode fields. For now use the .json file generated from etherlime compile
     */
    deploy(contract: CompiledContract, libraries?: Generic<string>, ...args: any[]): Promise<DeployedContractWrapper>;
    deployAndVerify(contract: CompiledContract, libraries?: Generic<string>, ...args: any[]): Promise<DeployedContractWrapper>;
    private _prepareAndDeployTransaction;
    /**
     *
     * Override for custom pre-send validation
     *
     * @param {*} contract the contract to be deployed
     * @param {*} deploymentArguments the deployment arguments
     */
    protected _preValidateArguments(contract: CompiledContract, deploymentArguments: any[]): Promise<void>;
    /**
     *
     * Override this to include custom logic for deploy transaction generation
     *
     * @param {*} contract the contract to be deployed
     * @param {*} deploymentArguments the arguments to this contract
     */
    private _prepareDeployTransaction;
    /**
     *
     * Override this for custom deploy transaction configuration
     *
     * @param {*} deployTransaction the transaction that is to be overridden
     */
    protected _overrideDeployTransactionConfig(deployTransaction: utils.UnsignedTransaction): Promise<utils.UnsignedTransaction>;
    /**
     *
     * Override this to include custom logic for sending the deploy transaction
     *
     * @param {*} deployTransaction the transaction that is to be sent
     */
    private _sendDeployTransaction;
    /**
     *
     * Override this to include custom logic for waiting for deployed transaction. For example you could trigger mined block for testrpc/ganache-cli
     *
     * @param {*} transaction The sent transaction object to be waited for
     */
    protected _waitForDeployTransaction(transaction: providers.TransactionResponse): Promise<providers.TransactionReceipt>;
    /**
     *
     * @param {*} contract the contract being deployed
     * @param {*} transaction the transaction object being sent
     * @param {*} transactionReceipt the transaction receipt
     */
    protected _postValidateTransaction(contract: CompiledContract, transaction: providers.TransactionResponse, transactionReceipt: providers.TransactionReceipt): Promise<void>;
    /**
     *
     * Override this for custom deployment result objects
     *
     * @param {*} contract the contract that has been deployed
     * @param {*} transaction the transaction object that was sent
     * @param {*} transactionReceipt the transaction receipt
     */
    protected _generateDeploymentResult(contract: CompiledContract, transaction: providers.TransactionResponse, transactionReceipt: providers.TransactionReceipt): Promise<DeployedContractWrapper>;
    /**
     *
     * Override this for custom logging functionality
     *
     * @param {*} deployerType type of deployer
     * @param {*} nameOrLabel name of the contract or label of the transaction
     * @param {*} transactionHash transaction hash if available
     * @param {*} status 0 - success, 1 - failure
     * @param {*} gasPrice the gas price param that was used by this transaction
     * @param {*} gasUsed the gas used by this transaction
     * @param {*} result arbitrary result text
     */
    protected _logAction(deployerType: string, nameOrLabel: string, transactionHash: string, status: number, gasPrice: string, gasUsed: string, result: string, solcVersion: string, verification: boolean): Promise<void>;
    /**
     *
     * Use this method to wrap an existing address in DeployedContractWrapper. You can use the goodies of the DeployedContractWrapper the same way you can do with a contract you've just deployed.
     *
     * @dev Useful for upgradability
     *
     * @param {*} contract
     * @param {*} contractAddress
     *
     * @return
     */
    wrapDeployedContract(contract: CompiledContract, contractAddress: string): DeployedContractWrapper;
    /**
     *
     * Use this estimate deployment gas cost for given transaction
     *
     * @return the gas it is going to cost
     *
     * @param {*} contract the contract object to be deployed. Must have at least abi and bytecode fields. For now use the .json file generated from etherlime compile. Add the deployment params as comma separated values
     */
    estimateGas(contract: CompiledContract, libraries?: Generic<string>, ...args: any[]): Promise<string>;
    private _estimateTransactionGas;
    /**
     *
     * Link a library or number of libraries to a contract
     *
     * @param {*} libraries The libraries which will be linked to the contract
     * @param {*} bytecode The contract's bytecode which be used for linking
     */
    private _prepareBytecode;
}
export default Deployer;
