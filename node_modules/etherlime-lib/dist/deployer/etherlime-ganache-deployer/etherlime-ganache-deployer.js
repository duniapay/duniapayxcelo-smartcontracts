"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const etherlime_utils_1 = require("etherlime-utils");
const jsonrpc_private_key_deployer_1 = require("./../jsonrpc-deployer/jsonrpc-private-key-deployer");
const etherlime_config_1 = require("etherlime-config");
const etherlime_ganache_wrapper_1 = require("./../../deployed-contract/etherlime-ganache-wrapper");
const etherlime_logger_1 = require("etherlime-logger");
class EtherlimeGanacheDeployer extends jsonrpc_private_key_deployer_1.default {
    /**
     *
     * Instantiates new deployer based on the GanacheCli Provider; If no privateKey and nodeUrl are specified, the deployer will be instantiated with the default values from cli-commands/ganache/setup.json
     *
     * @param {*} privateKey the private key for the deployer wallet/signer instance
     * @param {*} port port number of the network to deploy on. This is the port number that is given to the class
     * @param {*} defaultOverrides [Optional] default deployment overrides
     */
    constructor(privateKey = etherlime_config_1.ganacheSetupConfig.accounts[0].secretKey, port = etherlime_config_1.ganacheSetupConfig.defaultPort, defaultOverrides) {
        EtherlimeGanacheDeployer._validatePortInput(port);
        const nodeUrl = `http://localhost:${port}/`;
        super(privateKey, nodeUrl, defaultOverrides);
        this.nodeUrl = nodeUrl;
    }
    setPort(port) {
        EtherlimeGanacheDeployer._validatePortInput(port);
        const nodeUrl = `http://localhost:${port}/`;
        this.setNodeUrl(nodeUrl);
    }
    static _validatePortInput(port) {
        if (!etherlime_utils_1.isNumber(port)) {
            throw new Error(`Passed port (${port}) is not valid port`);
        }
    }
    toString() {
        const superString = super.toString();
        return `Network: ${etherlime_utils_1.colors.colorNetwork(this.nodeUrl)}\n${superString}`;
    }
    _waitForDeployTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.provider.send('evm_mine', []);
            return this.provider.getTransactionReceipt(transaction.hash);
        });
    }
    _generateDeploymentResult(contract, transaction, transactionReceipt) {
        return __awaiter(this, void 0, void 0, function* () {
            etherlime_logger_1.logger.log(`Contract ${etherlime_utils_1.colors.colorName(contract.contractName)} deployed at address: ${etherlime_utils_1.colors.colorAddress(transactionReceipt.contractAddress)}`);
            return new etherlime_ganache_wrapper_1.default(contract, transactionReceipt.contractAddress, this.signer, this.provider);
        });
    }
    wrapDeployedContract(contract, contractAddress) {
        etherlime_logger_1.logger.log(`Wrapping contract ${etherlime_utils_1.colors.colorName(contract.contractName)} at address: ${etherlime_utils_1.colors.colorAddress(contractAddress)}`);
        return new etherlime_ganache_wrapper_1.default(contract, contractAddress, this.signer, this.provider);
    }
}
exports.default = EtherlimeGanacheDeployer;
//# sourceMappingURL=etherlime-ganache-deployer.js.map