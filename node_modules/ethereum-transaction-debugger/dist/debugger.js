(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("Debugger", [], factory);
	else if(typeof exports === 'object')
		exports["Debugger"] = factory();
	else
		root["Debugger"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 33);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("debug");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.prefixName = prefixName;
exports.keccak256 = keccak256;
exports.stableKeccak256 = stableKeccak256;
exports.isCallMnemonic = isCallMnemonic;
exports.isShortCallMnemonic = isShortCallMnemonic;
exports.isCreateMnemonic = isCreateMnemonic;

var _truffleDecodeUtils = __webpack_require__(3);

var utils = _interopRequireWildcard(_truffleDecodeUtils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

const stringify = __webpack_require__(41);

function prefixName(prefix, fn) {
  Object.defineProperty(fn, "name", {
    value: `${prefix}.${fn.name}`,
    configurable: true
  });

  return fn;
}

/**
 * @return 0x-prefix string of keccak256 hash
 */
function keccak256(...args) {
  return utils.Conversion.toHexString(utils.EVM.keccak256(...args));
}

/**
 * Given an object, return a stable hash by first running it through a stable
 * stringify operation before hashing
 */
function stableKeccak256(obj) {
  return keccak256({ type: "string", value: stringify(obj) });
}

/*
 * Given a mmemonic, determine whether it's the mnemonic of a calling
 * instruction (does NOT include creation instructions)
 */
function isCallMnemonic(op) {
  const calls = ["CALL", "DELEGATECALL", "STATICCALL", "CALLCODE"];
  return calls.includes(op);
}

/*
 * returns true for mnemonics for calls that take only 6 args instead of 7
 */
function isShortCallMnemonic(op) {
  const shortCalls = ["DELEGATECALL", "STATICCALL"];
  return shortCalls.includes(op);
}

/*
 * Given a mmemonic, determine whether it's the mnemonic of a creation
 * instruction
 */
function isCreateMnemonic(op) {
  const creates = ["CREATE", "CREATE2"];
  return creates.includes(op);
}

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = require("reselect-tree");

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = require("truffle-decode-utils");

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("redux-saga/effects");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/entries");

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = require("redux");

/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/helpers/extends");

/***/ }),
/* 8 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/assign");

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(7);

var _extends3 = _interopRequireDefault(_extends2);

var _entries = __webpack_require__(5);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(8);

var _assign2 = _interopRequireDefault(_assign);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(2);

var _truffleSolidityUtils = __webpack_require__(42);

var _truffleSolidityUtils2 = _interopRequireDefault(_truffleSolidityUtils);

var _truffleCodeUtils = __webpack_require__(43);

var _truffleCodeUtils2 = _interopRequireDefault(_truffleCodeUtils);

var _truffleDecodeUtils = __webpack_require__(3);

var DecodeUtils = _interopRequireWildcard(_truffleDecodeUtils);

var _map = __webpack_require__(27);

var _jsonPointer = __webpack_require__(22);

var _jsonPointer2 = _interopRequireDefault(_jsonPointer);

var _selectors = __webpack_require__(10);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:solidity:selectors");

const semver = __webpack_require__(47);

function getSourceRange(instruction = {}) {
  return {
    start: instruction.start || 0,
    length: instruction.length || 0,
    lines: instruction.range || {
      start: {
        line: 0,
        column: 0
      },
      end: {
        line: 0,
        column: 0
      }
    }
  };
}

let solidity = (0, _reselectTree.createSelectorTree)({
  /**
   * solidity.state
   */
  state: state => state.solidity,

  /**
   * solidity.info
   */
  info: {
    /**
     * solidity.info.sources
     */
    sources: (0, _reselectTree.createLeaf)(["/state"], state => state.info.sources.byId),

    /**
     * solidity.info.sourceMaps
     */
    sourceMaps: (0, _reselectTree.createLeaf)(["/state"], state => state.info.sourceMaps.byContext)
  },

  /**
   * solidity.current
   */
  current: {
    /**
     * solidity.current.sourceMap
     */
    sourceMap: (0, _reselectTree.createLeaf)([_selectors2.default.current.context, "/info/sourceMaps"], ({ context }, sourceMaps) => sourceMaps[context] || {}),

    /**
     * solidity.current.functionDepth
     */
    functionDepth: state => state.solidity.proc.functionDepth,

    /**
     * solidity.current.instructions
     */
    instructions: (0, _reselectTree.createLeaf)(["/info/sources", _selectors2.default.current.context, "./sourceMap"], (sources, { binary }, { sourceMap }) => {
      if (!binary) {
        return [];
      }

      let instructions = _truffleCodeUtils2.default.parseCode(binary);

      if (!sourceMap) {
        // Let's create a source map to use since none exists. This source map
        // maps just as many ranges as there are instructions, and ensures every
        // instruction is marked as "jumping out". This will ensure all
        // available debugger commands step one instruction at a time.
        //
        // This is kindof a hack; perhaps this should be broken out into separate
        // context types. TODO
        sourceMap = "";
        for (var i = 0; i < instructions.length; i++) {
          sourceMap += i + ":" + i + ":1:-1;";
        }
      }

      var lineAndColumnMappings = (0, _assign2.default)({}, ...(0, _entries2.default)(sources).map(([id, { source }]) => ({
        [id]: _truffleSolidityUtils2.default.getCharacterOffsetToLineAndColumnMapping(source || "")
      })));
      var humanReadableSourceMap = _truffleSolidityUtils2.default.getHumanReadableSourceMap(sourceMap);

      let primaryFile = humanReadableSourceMap[0].file;
      debug("primaryFile %o", primaryFile);

      return instructions.map((instruction, index) => {
        // lookup source map by index and add `index` property to
        // instruction
        //

        const sourceMap = humanReadableSourceMap[index] || {};

        return {
          instruction: (0, _extends3.default)({}, instruction, { index }),
          sourceMap
        };
      }).map(({ instruction, sourceMap }) => {
        // add source map information to instruction, or defaults
        //

        const {
          jump,
          start = 0,
          length = 0,
          file = primaryFile
        } = sourceMap;
        const lineAndColumnMapping = lineAndColumnMappings[file] || {};
        const range = {
          start: lineAndColumnMapping[start] || {
            line: null,
            column: null
          },
          end: lineAndColumnMapping[start + length] || {
            line: null,
            column: null
          }
        };

        if (range.start.line === null) {
          debug("sourceMap %o", sourceMap);
        }

        return (0, _extends3.default)({}, instruction, {

          jump,
          start,
          length,
          file,
          range
        });
      });
    }),

    /**
     * solidity.current.instructionAtProgramCounter
     */
    instructionAtProgramCounter: (0, _reselectTree.createLeaf)(["./instructions"], instructions => {
      let map = [];
      instructions.forEach(function (instruction) {
        map[instruction.pc] = instruction;
      });

      // fill in gaps in map by defaulting to the last known instruction
      let lastSeen = null;
      for (let [pc, instruction] of map.entries()) {
        if (instruction) {
          lastSeen = instruction;
        } else {
          map[pc] = lastSeen;
        }
      }
      return map;
    }),

    /**
     * solidity.current.instruction
     */
    instruction: (0, _reselectTree.createLeaf)(["./instructionAtProgramCounter", _selectors2.default.current.step.programCounter], (map, pc) => map[pc] || {}),

    /**
     * solidity.current.source
     */
    source: (0, _reselectTree.createLeaf)(["/info/sources", "./instruction"], (sources, { file: id }) => sources[id] || {}),

    /**
     * solidity.current.sourceRange
     */
    sourceRange: (0, _reselectTree.createLeaf)(["./instruction"], getSourceRange),

    /**
     * solidity.current.isSourceRangeFinal
     */
    isSourceRangeFinal: (0, _reselectTree.createLeaf)(["./instructionAtProgramCounter", _selectors2.default.current.step.programCounter, _selectors2.default.next.step.programCounter], (map, current, next) => {
      if (!map[next]) {
        return true;
      }

      current = map[current];
      next = map[next];

      return current.start != next.start || current.length != next.length || current.file != next.file;
    }),

    /**
     * solidity.current.isMultiline
     */
    isMultiline: (0, _reselectTree.createLeaf)(["./sourceRange"], ({ lines }) => lines.start.line != lines.end.line),

    /**
     * solidity.current.willJump
     */
    willJump: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.isJump], isJump => isJump),

    /**
     * solidity.current.jumpDirection
     */
    jumpDirection: (0, _reselectTree.createLeaf)(["./instruction"], (i = {}) => i.jump || "-"),

    /**
     * solidity.current.willCall
     */
    willCall: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.isCall], x => x),

    /**
     * solidity.current.willCreate
     */
    willCreate: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.isCreate], x => x),

    /**
     * solidity.current.callsPrecompile
     */
    callsPrecompile: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.callsPrecompile], x => x),

    /**
     * solidity.current.willReturn
     */
    willReturn: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.isHalting], isHalting => isHalting),

    //HACK: DUPLICATE CODE FOLLOWS
    //The following code duplicates some selectors in ast.
    //This exists to suppor the solidity.current.contractCall workaround below.
    //This should be cleaned up later.

    /**
     * solidity.current.pointer
     * HACK duplicates ast.current.pointer
     */
    pointer: (0, _reselectTree.createLeaf)(["./source", "./sourceRange"], ({ ast }, range) => (0, _map.findRange)(ast, range.start, range.length)),

    /**
     * solidity.current.node
     * HACK duplicates ast.current.node
     */
    node: (0, _reselectTree.createLeaf)(["./source", "./pointer"], ({ ast }, pointer) => pointer ? _jsonPointer2.default.get(ast, pointer) : _jsonPointer2.default.get(ast, "")),

    /**
     * solidity.current.isContractCall
     * HACK WORKAROUND (only applies to solc version <0.5.1)
     * this selector exists to work around a problem in solc
     * it attempts to detect whether the current node is a contract method call
     * (or library method call)
     * it will not successfully detect this if the method was first placed in a
     * function variable, only if it is being called directly
     */
    isContractCall: (0, _reselectTree.createLeaf)(["./node"], node => node !== undefined && node.nodeType === "FunctionCall" && node.expression !== undefined && node.expression.nodeType === "MemberAccess" && node.expression.expression !== undefined && (DecodeUtils.Definition.isContract(node.expression.expression) || DecodeUtils.Definition.isContractType(node.expression.expression))),

    /**
     * solidity.current.needsFunctionDepthWorkaround
     * HACK
     * Determines if the solidity version used for the contract about to be
     * called was <0.5.1, to determine whether to use the above workaround
     * Only call this if the current step is a call or create!
     */
    needsFunctionDepthWorkaround: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.callContext], context => context.compiler !== undefined && //would be undefined for e.g. a precompile
    context.compiler.name === "solc" && semver.satisfies(context.compiler.version, "<0.5.1"))
  }
});

exports.default = solidity;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = __webpack_require__(5);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(8);

var _assign2 = _interopRequireDefault(_assign);

var _extends2 = __webpack_require__(7);

var _extends3 = _interopRequireDefault(_extends2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(2);

var _fastLevenshtein = __webpack_require__(46);

var _fastLevenshtein2 = _interopRequireDefault(_fastLevenshtein);

var _selectors = __webpack_require__(16);

var _selectors2 = _interopRequireDefault(_selectors);

var _helpers = __webpack_require__(1);

var _truffleDecodeUtils = __webpack_require__(3);

var DecodeUtils = _interopRequireWildcard(_truffleDecodeUtils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:evm:selectors"); // eslint-disable-line no-unused-vars

function findContext({ address, binary }, instances, search, contexts) {
  let record;
  if (address) {
    record = instances[address];
    if (!record) {
      return { address };
    }
    binary = record.binary;
  } else {
    record = search(binary);
  }

  let context = contexts[(record || {}).context];

  return (0, _extends3.default)({}, context, {
    binary
  });
}

/**
 * create EVM-level selectors for a given trace step selector
 * may specify additional selectors to include
 */
function createStepSelectors(step, state = null) {
  let base = {
    /**
     * .trace
     *
     * trace step info related to operation
     */
    trace: (0, _reselectTree.createLeaf)([step], ({ gasCost, op, pc }) => ({ gasCost, op, pc })),

    /**
     * .programCounter
     */
    programCounter: (0, _reselectTree.createLeaf)(["./trace"], step => step.pc),

    /**
     * .isJump
     */
    isJump: (0, _reselectTree.createLeaf)(["./trace"], step => step.op != "JUMPDEST" && step.op.indexOf("JUMP") == 0),

    /**
     * .isCall
     *
     * whether the opcode will switch to another calling context
     */
    isCall: (0, _reselectTree.createLeaf)(["./trace"], step => (0, _helpers.isCallMnemonic)(step.op)),

    /**
     * .isShortCall
     *
     * for calls that only take 6 arguments instead of 7
     */
    isShortCall: (0, _reselectTree.createLeaf)(["./trace"], step => (0, _helpers.isShortCallMnemonic)(step.op)),

    /**
     * .isCreate
     */
    isCreate: (0, _reselectTree.createLeaf)(["./trace"], step => (0, _helpers.isCreateMnemonic)(step.op)),

    /**
     * .isHalting
     *
     * whether the instruction halts or returns from a calling context
     */
    isHalting: (0, _reselectTree.createLeaf)(["./trace"], step => step.op == "STOP" || step.op == "RETURN")
  };

  if (state) {
    const isRelative = path => typeof path == "string" && (path.startsWith("./") || path.startsWith("../"));

    if (isRelative(state)) {
      state = `../${state}`;
    }

    (0, _assign2.default)(base, {
      /**
       * .callAddress
       *
       * address transferred to by call operation
       */
      callAddress: (0, _reselectTree.createLeaf)(["./isCall", "./trace", state], (matches, step, { stack }) => {
        if (!matches) return null;

        let address = stack[stack.length - 2];
        return DecodeUtils.Conversion.toAddress(address);
      }),

      /**
       * .createBinary
       *
       * binary code to execute via create operation
       */
      createBinary: (0, _reselectTree.createLeaf)(["./isCreate", "./trace", state], (matches, step, { stack, memory }) => {
        if (!matches) return null;

        // Get the code that's going to be created from memory.
        // Note we multiply by 2 because these offsets are in bytes.
        const offset = parseInt(stack[stack.length - 2], 16) * 2;
        const length = parseInt(stack[stack.length - 3], 16) * 2;

        return "0x" + memory.join("").substring(offset, offset + length);
      }),

      /**
       * .callData
       *
       * data passed to EVM call
       */
      callData: (0, _reselectTree.createLeaf)(["./isCall", "./isShortCall", "./trace", state], (matches, short, step, { stack, memory }) => {
        if (!matches) return null;

        //if it's 6-argument call, the data start and offset will be one spot
        //higher in the stack than they would be for a 7-argument call, so
        //let's introduce an offset to handle this
        let argOffset = short ? 1 : 0;

        // Get the data from memory.
        // Note we multiply by 2 because these offsets are in bytes.
        const offset = parseInt(stack[stack.length - 4 + argOffset], 16) * 2;
        const length = parseInt(stack[stack.length - 5 + argOffset], 16) * 2;

        return "0x" + memory.join("").substring(offset, offset + length);
      }),

      /**
       * .callContext
       *
       * context for what we're about to call into (or create)
       */
      callContext: (0, _reselectTree.createLeaf)(["./callAddress", "./createBinary", "/info/instances", "/info/binaries/search", "/info/contexts"], (address, binary, instances, search, contexts) => findContext({ address, binary }, instances, search, contexts)),

      /**
       * .callsPrecompile
       *
       * is the call address to a precompiled contract?
       * HACK
       */
      callsPrecompile: (0, _reselectTree.createLeaf)(["./callAddress", "/info/contexts", "/info/instances"], (address, contexts, instances) => {
        if (!address) return null;

        let { context } = instances[address] || {};
        let { binary } = contexts[context] || {};
        return !binary;
      })
    });
  }

  return base;
}

const evm = (0, _reselectTree.createSelectorTree)({
  /**
   * evm.state
   */
  state: state => state.evm,

  /**
   * evm.info
   */
  info: {
    /**
     * evm.info.contexts
     */
    contexts: (0, _reselectTree.createLeaf)(["/state"], state => state.info.contexts.byContext),

    /**
     * evm.info.instances
     */
    instances: (0, _reselectTree.createLeaf)(["/state"], state => state.info.instances.byAddress),

    /**
     * evm.info.binaries
     */
    binaries: {
      _: (0, _reselectTree.createLeaf)(["/state"], state => state.info.contexts.byBinary),

      /**
       * evm.info.binaries.search
       *
       * returns function (binary) => context
       */
      search: (0, _reselectTree.createLeaf)(["./_"], binaries => binary => {
        // search for a given binary based on levenshtein distances to
        // existing (known) context binaries.
        //
        // levenshtein distance is the number of textual modifications
        // (insert, change, delete) required to convert string a to b
        //
        // filter by a percentage threshold
        const threshold = 0.25;

        // skip levenshtein check for undefined binaries
        if (!binary || binary == "0x0") {
          return {};
        }

        const results = (0, _entries2.default)(binaries).map(([knownBinary, { context }]) => ({
          context,
          distance: _fastLevenshtein2.default.get(knownBinary, binary)
        })).filter(({ distance }) => distance <= binary.length * threshold).sort(({ distance: a }, { distance: b }) => a - b);

        if (results[0]) {
          const { context } = results[0];
          return { context };
        }

        return {};
      })
    }
  },

  /**
   * evm.current
   */
  current: {
    /**
     * evm.current.callstack
     */
    callstack: state => state.evm.proc.callstack,

    /**
     * evm.current.call
     */
    call: (0, _reselectTree.createLeaf)(["./callstack"], stack => stack.length ? stack[stack.length - 1] : {}),

    /**
     * evm.current.creationDepth
     * how many creation calls are currently on the call stack?
     */
    creationDepth: (0, _reselectTree.createLeaf)(["./callstack"], stack => stack.filter(call => call.address === undefined).length),

    /**
     * evm.current.context
     */
    context: (0, _reselectTree.createLeaf)(["./call", "/info/instances", "/info/binaries/search", "/info/contexts"], findContext),

    /**
     * evm.current.state
     *
     * evm state info: as of last operation, before op defined in step
     */
    state: (0, _assign2.default)({}, ...["depth", "error", "gas", "memory", "stack", "storage"].map(param => ({
      [param]: (0, _reselectTree.createLeaf)([_selectors2.default.step], step => step[param])
    }))),

    /**
     * evm.current.step
     */
    step: createStepSelectors(_selectors2.default.step, "./state")
  },

  /**
   * evm.next
   */
  next: {
    /**
     * evm.next.state
     *
     * evm state as a result of next step operation
     */
    state: (0, _assign2.default)({}, ...["depth", "error", "gas", "memory", "stack", "storage"].map(param => ({
      [param]: (0, _reselectTree.createLeaf)([_selectors2.default.next], step => step[param])
    }))),

    step: createStepSelectors(_selectors2.default.next, "./state")
  }
});

exports.default = evm;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.saveSteps = saveSteps;
exports.receiveAddresses = receiveAddresses;
exports.next = next;
exports.tick = tick;
exports.tock = tock;
exports.endTrace = endTrace;
exports.reset = reset;
exports.subtock = subtock;
const SAVE_STEPS = exports.SAVE_STEPS = "SAVE_STEPS";
function saveSteps(steps) {
  return {
    type: SAVE_STEPS,
    steps
  };
}

const RECEIVE_ADDRESSES = exports.RECEIVE_ADDRESSES = "RECEIVE_ADDRESSES";
function receiveAddresses(addresses) {
  return {
    type: RECEIVE_ADDRESSES,
    addresses
  };
}

const NEXT = exports.NEXT = "NEXT";
function next() {
  return { type: NEXT };
}

const TICK = exports.TICK = "TICK";
function tick() {
  return { type: TICK };
}

const TOCK = exports.TOCK = "TOCK";
function tock() {
  return { type: TOCK };
}

const END_OF_TRACE = exports.END_OF_TRACE = "EOT";
function endTrace() {
  return { type: END_OF_TRACE };
}

const RESET = exports.RESET = "TRACE_RESET";
function reset() {
  return { type: RESET };
}

const BACKTICK = exports.BACKTICK = "BACKTICK";
function subtock() {
  return { type: BACKTICK };
}

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = __webpack_require__(18);

var _set2 = _interopRequireDefault(_set);

exports.advance = advance;
exports.signalTickSagaCompletion = signalTickSagaCompletion;
exports.processTrace = processTrace;
exports.reset = reset;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(4);

var _helpers = __webpack_require__(1);

var _truffleDecodeUtils = __webpack_require__(3);

var DecodeUtils = _interopRequireWildcard(_truffleDecodeUtils);

var _actions = __webpack_require__(11);

var actions = _interopRequireWildcard(_actions);

var _selectors = __webpack_require__(16);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:trace:sagas");

function* waitForTrace() {
  let { steps } = yield (0, _effects.take)(actions.SAVE_STEPS);

  let addresses = [...new _set2.default(steps.filter(({ op }) => (0, _helpers.isCallMnemonic)(op)).map(({ stack }) => DecodeUtils.Conversion.toAddress(stack[stack.length - 2])))];

  yield (0, _effects.put)(actions.receiveAddresses(addresses));
}

function* advance() {
  yield (0, _effects.put)(actions.next());

  debug("TOCK to take");
  yield (0, _effects.take)([actions.TOCK, actions.END_OF_TRACE]);
  debug("TOCK taken");
}

const SUBMODULE_COUNT = 3; //data, evm, solidity

function* next() {
  let remaining = yield (0, _effects.select)(_selectors2.default.stepsRemaining);
  debug("remaining: %o", remaining);
  let steps = yield (0, _effects.select)(_selectors2.default.steps);
  debug("total steps: %o", steps.length);
  let waitingForSubmodules = 0;

  if (remaining > 0) {
    debug("putting TICK");
    // updates state for current step
    waitingForSubmodules = SUBMODULE_COUNT;
    yield (0, _effects.put)(actions.tick());
    debug("put TICK");

    //wait for all subtocks before continuing
    while (waitingForSubmodules > 0) {
      yield (0, _effects.take)(actions.BACKTICK);
      debug("got BACKTICK");
      waitingForSubmodules--;
    }

    remaining--; // local update, just for convenience
  }

  if (remaining) {
    debug("putting TOCK");
    // updates step to next step in trace
    yield (0, _effects.put)(actions.tock());
    debug("put TOCK");
  } else {
    debug("putting END_OF_TRACE");
    yield (0, _effects.put)(actions.endTrace());
    debug("put END_OF_TRACE");
  }
}

function* signalTickSagaCompletion() {
  yield (0, _effects.put)(actions.subtock());
}

function* processTrace(trace) {
  yield (0, _effects.put)(actions.saveSteps(trace));

  let { addresses } = yield (0, _effects.take)(actions.RECEIVE_ADDRESSES);
  debug("received addresses");

  return addresses;
}

function* reset() {
  yield (0, _effects.put)(actions.reset());
}

function* saga() {
  // wait for trace to be defined
  yield* waitForTrace();

  yield (0, _effects.takeEvery)(actions.NEXT, next);
}

exports.default = (0, _helpers.prefixName)("trace", saga);

/***/ }),
/* 13 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/helpers/asyncToGenerator");

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.start = start;
exports.ready = ready;
exports.error = error;
exports.recordContracts = recordContracts;
exports.saveTransaction = saveTransaction;
exports.saveReceipt = saveReceipt;
const START = exports.START = "SESSION_START";
function start(txHash, provider) {
  return {
    type: START,
    txHash,
    provider
  };
}

const READY = exports.READY = "SESSION_READY";
function ready() {
  return {
    type: READY
  };
}

const ERROR = exports.ERROR = "SESSION_ERROR";
function error(error) {
  return {
    type: ERROR,
    error
  };
}

const RECORD_CONTRACTS = exports.RECORD_CONTRACTS = "RECORD_CONTRACTS";
function recordContracts(contexts, sources) {
  return {
    type: RECORD_CONTRACTS,
    contexts,
    sources
  };
}

const SAVE_TRANSACTION = exports.SAVE_TRANSACTION = "SAVE_TRANSACTION";
function saveTransaction(transaction) {
  return {
    type: SAVE_TRANSACTION,
    transaction
  };
}

const SAVE_RECEIPT = exports.SAVE_RECEIPT = "SAVE_RECEIPT";
function saveReceipt(receipt) {
  return {
    type: SAVE_RECEIPT,
    receipt
  };
}

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(2);

var _jsonPointer = __webpack_require__(22);

var _jsonPointer2 = _interopRequireDefault(_jsonPointer);

var _selectors = __webpack_require__(9);

var _selectors2 = _interopRequireDefault(_selectors);

var _map = __webpack_require__(27);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:ast:selectors");

/**
 * ast
 */
const ast = (0, _reselectTree.createSelectorTree)({
  /**
   * ast.views
   */
  views: {
    /**
     * ast.views.sources
     */
    sources: (0, _reselectTree.createLeaf)([_selectors2.default.info.sources], sources => sources)
  },

  /**
   * ast.current
   */
  current: {

    /**
     * ast.current.tree
     *
     * ast for current source
     */
    tree: (0, _reselectTree.createLeaf)([_selectors2.default.current.source], ({ ast }) => ast),

    /**
     * ast.current.index
     *
     * source ID
     */
    index: (0, _reselectTree.createLeaf)([_selectors2.default.current.source], ({ id }) => id),

    /**
     * ast.current.pointer
     *
     * jsonpointer for current ast node
     */
    pointer: (0, _reselectTree.createLeaf)(["./tree", _selectors2.default.current.sourceRange], (ast, range) => (0, _map.findRange)(ast, range.start, range.length)),

    /**
     * ast.current.node
     *
     * current ast node to execute
     */
    node: (0, _reselectTree.createLeaf)(["./tree", "./pointer"], (ast, pointer) => pointer ? _jsonPointer2.default.get(ast, pointer) : _jsonPointer2.default.get(ast, ""))

  }
});

exports.default = ast;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _reselectTree = __webpack_require__(2);

let trace = (0, _reselectTree.createSelectorTree)({
  /**
   * trace.index
   *
   * current step index
   */
  index: state => state.trace.proc.index,

  /**
   * trace.finished
   *
   * is the trace finished?
   */
  finished: state => state.trace.proc.finished,

  /**
   * trace.steps
   *
   * all trace steps
   */
  steps: state => state.trace.info.steps,

  /**
   * trace.stepsRemaining
   *
   * number of steps remaining in trace
   */
  stepsRemaining: (0, _reselectTree.createLeaf)(["./steps", "./index"], (steps, index) => steps.length - index),

  /**
   * trace.step
   *
   * current trace step
   */
  step: (0, _reselectTree.createLeaf)(["./steps", "./index"], (steps, index) => steps[index]),

  /**
   * trace.next
   *
   * next trace step
   * HACK: if at the end,
   * we will return the *same* trace step
   */
  next: (0, _reselectTree.createLeaf)(["./steps", "./index"], (steps, index) => index < steps.length - 1 ? steps[index + 1] : steps[index])
});

exports.default = trace;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(7);

var _extends3 = _interopRequireDefault(_extends2);

exports.scope = scope;
exports.declare = declare;
exports.defineType = defineType;
exports.reset = reset;
exports.learnAddressSaga = learnAddressSaga;
exports.recordAllocations = recordAllocations;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(4);

var _helpers = __webpack_require__(1);

var _actions = __webpack_require__(11);

var _actions2 = __webpack_require__(28);

var actions = _interopRequireWildcard(_actions2);

var _sagas = __webpack_require__(12);

var trace = _interopRequireWildcard(_sagas);

var _selectors = __webpack_require__(21);

var _selectors2 = _interopRequireDefault(_selectors);

var _truffleDecodeUtils = __webpack_require__(3);

var DecodeUtils = _interopRequireWildcard(_truffleDecodeUtils);

var _bn = __webpack_require__(50);

var _bn2 = _interopRequireDefault(_bn);

var _truffleDecoder = __webpack_require__(24);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:data:sagas"); // eslint-disable-line no-unused-vars

function* scope(nodeId, pointer, parentId, sourceId) {
  yield (0, _effects.put)(actions.scope(nodeId, pointer, parentId, sourceId));
}

function* declare(node) {
  yield (0, _effects.put)(actions.declare(node));
}

function* defineType(node) {
  yield (0, _effects.put)(actions.defineType(node));
}

function* tickSaga() {
  debug("got TICK");

  yield* variablesAndMappingsSaga();
  yield* trace.signalTickSagaCompletion();
}

function* variablesAndMappingsSaga() {
  let node = (yield (0, _effects.select)(_selectors2.default.views.ast)).node;
  let decode = yield (0, _effects.select)(_selectors2.default.views.decoder);
  let scopes = yield (0, _effects.select)(_selectors2.default.views.scopes.inlined);
  let referenceDeclarations = yield (0, _effects.select)(_selectors2.default.views.referenceDeclarations);
  let allocations = yield (0, _effects.select)(_selectors2.default.info.allocations.storage);
  let currentAssignments = yield (0, _effects.select)(_selectors2.default.proc.assignments);
  let mappedPaths = yield (0, _effects.select)(_selectors2.default.proc.mappedPaths);
  let currentDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
  let address = yield (0, _effects.select)(_selectors2.default.current.address); //may be undefined
  let dummyAddress = yield (0, _effects.select)(_selectors2.default.current.dummyAddress);

  let stack = yield (0, _effects.select)(_selectors2.default.next.state.stack); //note the use of next!
  //in this saga we are interested in the *results* of the current instruction
  //note that the decoder is still based on data.current.state; that's fine
  //though.  There's already a delay between when we record things off the
  //stack and when we decode them, after all.  Basically, nothing serious
  //should happen after an index node but before the index access node that
  //would cause storage, memory, or calldata to change, meaning that even if
  //the literal we recorded was a pointer, it will still be valid at the time
  //we use it.  (The other literals we make use of, for the base expressions,
  //are not decoded, so no potential mismatch there would be relevant anyway.)
  if (!stack) {
    return;
  }

  let top = stack.length - 1;
  var assignment, assignments, baseExpression, slot, path;

  if (!node) {
    return;
  }

  // stack is only ready for interpretation after the last step of each
  // source range
  //
  // the data module always looks at the result of a particular opcode
  // (i.e., the following trace step's stack/memory/storage), so this
  // asserts that the _current_ operation is the final one before
  // proceeding
  if (!(yield (0, _effects.select)(_selectors2.default.views.atLastInstructionForSourceRange))) {
    return;
  }

  switch (node.nodeType) {
    case "FunctionDefinition":
    case "ModifierDefinition":
      //NOTE: this will *not* catch most modifier definitions! BUG
      let parameters = node.parameters.parameters;
      //note that we do *not* include return parameters, since those are
      //handled by the VariableDeclaration case (no, I don't know why it
      //works out that way)
      let reverseParameters = parameters.slice().reverse();
      //reverse is in-place, so we use slice() to clone first
      debug("reverseParameters %o", parameters);

      let currentPosition = top;
      assignments = { byId: {} };

      for (let parameter of reverseParameters) {
        let words = DecodeUtils.Definition.stackSize(parameter);
        let pointer = {
          stack: {
            from: currentPosition - words + 1,
            to: currentPosition
          }
        };
        let assignment = makeAssignment({ astId: parameter.id, stackframe: currentDepth }, pointer);
        assignments.byId[assignment.id] = assignment;
        currentPosition -= words;
      }

      debug("Function definition case");
      debug("assignments %O", assignments);

      yield (0, _effects.put)(actions.assign(assignments));
      break;

    case "ContractDefinition":
      let allocation = allocations[node.id];

      debug("Contract definition case");
      debug("allocations %O", allocations);
      debug("allocation %O", allocation);
      assignments = { byId: {} };
      for (let id in allocation.members) {
        id = Number(id); //not sure why we're getting them as strings, but...
        let idObj = address !== undefined ? { astId: id, address } : { astId: id, dummyAddress };
        let fullId = (0, _helpers.stableKeccak256)(idObj);
        //we don't use makeAssignment here as we had to compute the ID anyway
        assignment = (0, _extends3.default)({}, idObj, {
          id: fullId,
          ref: (0, _extends3.default)({}, (currentAssignments.byId[fullId] || {}).ref || {}, allocation.members[id].pointer)
        });
        assignments.byId[fullId] = assignment;
      }
      debug("assignments %O", assignments);

      yield (0, _effects.put)(actions.assign(assignments));
      break;

    case "VariableDeclaration":
      let varId = node.id;
      debug("Variable declaration case");
      debug("currentDepth %d varId %d", currentDepth, varId);

      //NOTE: We're going to make the assignment conditional here; here's why.
      //There's a bug where calling the autogenerated accessor for a public
      //contract variable causes the debugger to see two additional
      //declarations for that variable... which this code reads as local
      //variable declarations.  Rather than prevent this at the source, we're
      //just going to check for it here, by not adding a local variable if said
      //variable is already a contract variable.

      if (currentAssignments.byAstId[varId] !== undefined && currentAssignments.byAstId[varId].some(id => currentAssignments.byId[id].address !== undefined || currentAssignments.byId[id].dummyAddress !== undefined)) {
        break;
      }

      //otherwise, go ahead and make the assignment
      assignment = makeAssignment({ astId: varId, stackframe: currentDepth }, {
        stack: {
          from: top - DecodeUtils.Definition.stackSize(node) + 1,
          to: top
        }
      });
      assignments = { byId: { [assignment.id]: assignment } };
      yield (0, _effects.put)(actions.assign(assignments));
      break;

    case "IndexAccess":
      // to track `mapping` types known indices
      // (and also *some* known indices for arrays)

      debug("Index access case");

      //we're going to start by doing the same thing as in the default case
      //(see below) -- getting things ready for an assignment.  Then we're
      //going to forget this for a bit while we handle the rest...
      assignments = literalAssignments(node, stack, currentDepth);

      //we'll need this
      baseExpression = node.baseExpression;

      //but first, a diversion -- is this something that could not *possibly*
      //lead to a mapping?  i.e., either a bytes, or an array of non-reference
      //types, or a non-storage array?
      //if so, we'll just do the assign and quit out early
      //(note: we write it this way because mappings aren't caught by
      //isReference)
      if (DecodeUtils.Definition.typeClass(baseExpression) === "bytes" || DecodeUtils.Definition.typeClass(baseExpression) === "array" && (DecodeUtils.Definition.isReference(node) ? DecodeUtils.Definition.referenceType(baseExpression) !== "storage" : !DecodeUtils.Definition.isMapping(node))) {
        debug("Index case bailed out early");
        debug("typeClass %s", DecodeUtils.Definition.typeClass(baseExpression));
        debug("referenceType %s", DecodeUtils.Definition.referenceType(baseExpression));
        debug("isReference(node) %o", DecodeUtils.Definition.isReference(node));
        yield (0, _effects.put)(actions.assign(assignments));
        break;
      }

      let keyDefinition = DecodeUtils.Definition.keyDefinition(baseExpression, scopes);
      //if we're dealing with an array, this will just hack up a uint definition
      //:)

      //begin subsection: key decoding
      //(I tried factoring this out into its own saga but it didn't work when I
      //did :P )
      yield (0, _effects.put)(actions.mapKeyDecoding(true));

      let indexValue;
      let indexDefinition = node.indexExpression;

      //why the loop? see the end of the block it heads for an explanatory
      //comment
      while (indexValue === undefined) {
        let indexId = indexDefinition.id;
        //indices need to be identified by stackframe
        let indexIdObj = { astId: indexId, stackframe: currentDepth };
        let fullIndexId = (0, _helpers.stableKeccak256)(indexIdObj);

        const indexReference = (currentAssignments.byId[fullIndexId] || {}).ref;

        if (DecodeUtils.Definition.isSimpleConstant(indexDefinition)) {
          //while the main case is the next one, where we look for a prior
          //assignment, we need this case (and need it first) for two reasons:
          //1. some constant expressions (specifically, string and hex literals)
          //aren't sourcemapped to and so won't have a prior assignment
          //2. if the key type is bytesN but the expression is constant, the
          //value will go on the stack *left*-padded instead of right-padded,
          //so looking for a prior assignment will read the wrong value.
          //so instead it's preferable to use the constant directly.
          indexValue = yield (0, _effects.call)(decode, keyDefinition, {
            definition: indexDefinition
          });
        } else if (indexReference) {
          //if a prior assignment is found
          let splicedDefinition;
          //in general, we want to decode using the key definition, not the index
          //definition. however, the key definition may have the wrong location
          //on it.  so, when applicable, we splice the index definition location
          //onto the key definition location.
          if (DecodeUtils.Definition.isReference(indexDefinition)) {
            splicedDefinition = DecodeUtils.Definition.spliceLocation(keyDefinition, DecodeUtils.Definition.referenceType(indexDefinition));
            //we could put code here to add on the "_ptr" ending when absent,
            //but we presently ignore that ending, so we'll skip that
          } else {
            splicedDefinition = keyDefinition;
          }
          indexValue = yield (0, _effects.call)(decode, splicedDefinition, indexReference);
        } else if (indexDefinition.referencedDeclaration && scopes[indexDefinition.referenceDeclaration]) {
          //there's one more reason we might have failed to decode it: it might be a
          //constant state variable.  Unfortunately, we don't know how to decode all
          //those at the moment, but we can handle the ones we do know how to decode.
          //In the future hopefully we will decode all of them
          debug("referencedDeclaration %d", indexDefinition.referencedDeclaration);
          let indexConstantDeclaration = scopes[indexDefinition.referencedDeclaration].definition;
          debug("indexConstantDeclaration %O", indexConstantDeclaration);
          if (indexConstantDeclaration.constant) {
            let indexConstantDefinition = indexConstantDeclaration.value;
            //next line filters out constants we don't know how to handle
            if (DecodeUtils.Definition.isSimpleConstant(indexConstantDefinition)) {
              indexValue = yield (0, _effects.call)(decode, keyDefinition, {
                definition: indexConstantDeclaration.value
              });
            }
          }
        }
        //there's still one more reason we might have failed to decode it:
        //certain (silent) type conversions aren't sourcemapped either.
        //(thankfully, any type conversion that actually *does* something seems
        //to be sourcemapped.)  So if we've failed to decode it, we try again
        //with the argument of the type conversion, if it is one; we leave
        //indexValue undefined so the loop will continue
        //(note that this case is last for a reason; if this were earlier, it
        //would catch *non*-silent type conversions, which we want to just read
        //off the stack)
        else if (indexDefinition.kind === "typeConversion") {
            indexDefinition = indexDefinition.arguments[0];
          }
          //otherwise, we've just totally failed to decode it, so we mark
          //indexValue as null (as distinct from undefined) to indicate this.  In
          //the future, we should be able to decode all mapping keys, but we're
          //not quite there yet, sorry (because we can't yet handle all constant
          //state variables)
          else {
              indexValue = null;
            }
        //now, as mentioned, retry in the typeConversion case
      }

      yield (0, _effects.put)(actions.mapKeyDecoding(false));
      //end subsection: key decoding

      debug("index value %O", indexValue);
      debug("keyDefinition %o", keyDefinition);

      //whew! But we're not done yet -- we need to turn this decoded key into
      //an actual path (assuming we *did* decode it)
      //OK, not an actual path -- we're just going to use a simple offset for
      //the path.  But that's OK, because the mappedPaths reducer will turn
      //it into an actual path.
      if (indexValue !== null) {
        path = fetchBasePath(baseExpression, mappedPaths, currentAssignments, currentDepth);

        let slot = { path };

        //we need to do things differently depending on whether we're dealing
        //with an array or mapping
        switch (DecodeUtils.Definition.typeClass(baseExpression)) {
          case "array":
            slot.hashPath = DecodeUtils.Definition.isDynamicArray(baseExpression);
            slot.offset = indexValue.muln((0, _truffleDecoder.storageSize)(node, referenceDeclarations, allocations).words);
            break;
          case "mapping":
            slot.key = indexValue;
            slot.keyEncoding = DecodeUtils.Definition.keyEncoding(keyDefinition);
            slot.offset = new _bn2.default(0);
            break;
          default:
            debug("unrecognized index access!");
        }
        debug("slot %O", slot);

        //now, map it! (and do the assign as well)
        yield (0, _effects.put)(actions.mapPathAndAssign(address || dummyAddress, slot, assignments, DecodeUtils.Definition.typeIdentifier(node), DecodeUtils.Definition.typeIdentifier(baseExpression)));
      } else {
        //if we failed to decode, just do the assign from above
        debug("failed to decode, just assigning");
        yield (0, _effects.put)(actions.assign(assignments));
      }

      break;

    case "MemberAccess":
      //we're going to start by doing the same thing as in the default case
      //(see below) -- getting things ready for an assignment.  Then we're
      //going to forget this for a bit while we handle the rest...
      assignments = literalAssignments(node, stack, currentDepth);

      debug("Member access case");

      //MemberAccess uses expression, not baseExpression
      baseExpression = node.expression;

      //if this isn't a storage struct, or the element isn't of reference type,
      //we'll just do the assignment and quit out (again, note that mappings
      //aren't caught by isReference)
      if (DecodeUtils.Definition.typeClass(baseExpression) !== "struct" || (DecodeUtils.Definition.isReference(node) ? DecodeUtils.Definition.referenceType(baseExpression) !== "storage" : !DecodeUtils.Definition.isMapping(node))) {
        debug("Member case bailed out early");
        yield (0, _effects.put)(actions.assign(assignments));
        break;
      }

      //but if it is a storage struct, we have to map the path as well
      path = fetchBasePath(baseExpression, mappedPaths, currentAssignments, currentDepth);

      slot = { path };

      let structId = DecodeUtils.Definition.typeId(baseExpression);
      let memberAllocation = allocations[structId].members[node.referencedDeclaration];

      slot.offset = memberAllocation.pointer.storage.from.slot.offset.clone();

      debug("slot %o", slot);
      yield (0, _effects.put)(actions.mapPathAndAssign(address || dummyAddress, slot, assignments, DecodeUtils.Definition.typeIdentifier(node), DecodeUtils.Definition.typeIdentifier(baseExpression)));

    default:
      if (node.typeDescriptions == undefined) {
        break;
      }

      debug("decoding expression value %O", node.typeDescriptions);
      debug("default case");
      debug("currentDepth %d node.id %d", currentDepth, node.id);

      assignments = literalAssignments(node, stack, currentDepth);
      yield (0, _effects.put)(actions.assign(assignments));
      break;
  }
}

function* reset() {
  yield (0, _effects.put)(actions.reset());
}

function* learnAddressSaga(dummyAddress, address) {
  debug("about to learn an address");
  yield (0, _effects.put)(actions.learnAddress(dummyAddress, address));
  debug("address learnt");
}

function* recordAllocations() {
  const contracts = yield (0, _effects.select)(_selectors2.default.views.userDefinedTypes.contractDefinitions);
  debug("contracts %O", contracts);
  const referenceDeclarations = yield (0, _effects.select)(_selectors2.default.views.referenceDeclarations);
  debug("referenceDeclarations %O", referenceDeclarations);
  const storageAllocations = (0, _truffleDecoder.getStorageAllocations)(referenceDeclarations, contracts);
  debug("storageAllocations %O", storageAllocations);
  const memoryAllocations = (0, _truffleDecoder.getMemoryAllocations)(referenceDeclarations);
  const calldataAllocations = (0, _truffleDecoder.getCalldataAllocations)(referenceDeclarations);
  yield (0, _effects.put)(actions.allocate(storageAllocations, memoryAllocations, calldataAllocations));
}

function makeAssignment(idObj, ref) {
  let id = (0, _helpers.stableKeccak256)(idObj);
  return (0, _extends3.default)({}, idObj, { id, ref });
}

function literalAssignments(node, stack, currentDepth) {
  let top = stack.length - 1;

  let literal = (0, _truffleDecoder.readStack)(stack, top - DecodeUtils.Definition.stackSize(node) + 1, top);

  let assignment = makeAssignment({ astId: node.id, stackframe: currentDepth }, { literal });

  return { byId: { [assignment.id]: assignment } };
}

function fetchBasePath(baseNode, mappedPaths, currentAssignments, currentDepth) {
  let fullId = (0, _helpers.stableKeccak256)({
    astId: baseNode.id,
    stackframe: currentDepth
  });
  //base expression is an expression, and so has a literal assigned to
  //it
  let offset = DecodeUtils.Conversion.toBN(currentAssignments.byId[fullId].ref.literal);
  return { offset };
}

function* saga() {
  yield (0, _effects.takeEvery)(_actions.TICK, tickSaga);
}

exports.default = (0, _helpers.prefixName)("data", saga);

/***/ }),
/* 18 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/set");

/***/ }),
/* 19 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/values");

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.advance = advance;
exports.stepNext = stepNext;
exports.stepOver = stepOver;
exports.stepInto = stepInto;
exports.stepOut = stepOut;
exports.reset = reset;
exports.interrupt = interrupt;
exports.continueUntilBreakpoint = continueUntilBreakpoint;
exports.addBreakpoint = addBreakpoint;
exports.removeBreakpoint = removeBreakpoint;
exports.removeAllBreakpoints = removeAllBreakpoints;
exports.doneStepping = doneStepping;
const ADVANCE = exports.ADVANCE = "ADVANCE";
function advance(count = 1) {
  return { type: ADVANCE, count };
}

const STEP_NEXT = exports.STEP_NEXT = "STEP_NEXT";
function stepNext() {
  return { type: STEP_NEXT };
}

const STEP_OVER = exports.STEP_OVER = "STEP_OVER";
function stepOver() {
  return { type: STEP_OVER };
}

const STEP_INTO = exports.STEP_INTO = "STEP_INTO";
function stepInto() {
  return { type: STEP_INTO };
}

const STEP_OUT = exports.STEP_OUT = "STEP_OUT";
function stepOut() {
  return { type: STEP_OUT };
}

const RESET = exports.RESET = "RESET";
function reset() {
  return { type: RESET };
}

const INTERRUPT = exports.INTERRUPT = "INTERRUPT";
function interrupt() {
  return { type: INTERRUPT };
}

const CONTINUE = exports.CONTINUE = "CONTINUE";
function continueUntilBreakpoint() {
  //"continue" is not a legal name
  return { type: CONTINUE };
}

const ADD_BREAKPOINT = exports.ADD_BREAKPOINT = "ADD_BREAKPOINT";
function addBreakpoint(breakpoint) {
  return {
    type: ADD_BREAKPOINT,
    breakpoint
  };
}

const REMOVE_BREAKPOINT = exports.REMOVE_BREAKPOINT = "REMOVE_BREAKPOINT";
function removeBreakpoint(breakpoint) {
  return {
    type: REMOVE_BREAKPOINT,
    breakpoint
  };
}

const REMOVE_ALL_BREAKPOINTS = exports.REMOVE_ALL_BREAKPOINTS = "REMOVE_ALL_BREAKPOINTS";
function removeAllBreakpoints() {
  return {
    type: REMOVE_ALL_BREAKPOINTS
  };
}

const DONE_STEPPING = exports.DONE_STEPPING = "DONE_STEPPING";
function doneStepping() {
  return {
    type: DONE_STEPPING
  };
}

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = __webpack_require__(26);

var _promise2 = _interopRequireDefault(_promise);

var _asyncToGenerator2 = __webpack_require__(13);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _values = __webpack_require__(19);

var _values2 = _interopRequireDefault(_values);

var _extends2 = __webpack_require__(7);

var _extends3 = _interopRequireDefault(_extends2);

var _entries = __webpack_require__(5);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(8);

var _assign2 = _interopRequireDefault(_assign);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(2);

var _jsonPointer = __webpack_require__(22);

var _jsonPointer2 = _interopRequireDefault(_jsonPointer);

var _helpers = __webpack_require__(1);

var _selectors = __webpack_require__(15);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(10);

var _selectors4 = _interopRequireDefault(_selectors3);

var _selectors5 = __webpack_require__(9);

var _selectors6 = _interopRequireDefault(_selectors5);

var _truffleDecodeUtils = __webpack_require__(3);

var DecodeUtils = _interopRequireWildcard(_truffleDecodeUtils);

var _truffleDecoder = __webpack_require__(24);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:data:selectors"); // eslint-disable-line no-unused-vars

/**
 * @private
 */
const identity = x => x;

const data = (0, _reselectTree.createSelectorTree)({
  state: state => state.data,

  /**
   * data.views
   */
  views: {
    /**
     * data.views.ast
     */
    ast: (0, _reselectTree.createLeaf)([_selectors2.default.current], tree => tree),

    /*
     * data.views.atLastInstructionForSourceRange
     */
    atLastInstructionForSourceRange: (0, _reselectTree.createLeaf)([_selectors6.default.current.isSourceRangeFinal], final => final),

    /**
     * data.views.scopes (namespace)
     */
    scopes: {
      /**
       * data.views.scopes.inlined (namespace)
       */
      inlined: {
        /**
         * data.views.scopes.inlined (selector)
         * see data.info.scopes for how this differs from the raw version
         */
        _: (0, _reselectTree.createLeaf)(["/info/scopes", "./raw"], (scopes, inlined) => (0, _assign2.default)({}, ...(0, _entries2.default)(inlined).map(([id, info]) => {
          let newInfo = (0, _extends3.default)({}, info);
          newInfo.variables = scopes[id].variables;
          return { [id]: newInfo };
        }))),

        /**
         * data.views.scopes.inlined.raw
         */
        raw: (0, _reselectTree.createLeaf)(["/info/scopes/raw", _selectors6.default.info.sources], (scopes, sources) => (0, _assign2.default)({}, ...(0, _entries2.default)(scopes).map(([id, entry]) => ({
          [id]: (0, _extends3.default)({}, entry, {

            definition: _jsonPointer2.default.get(sources[entry.sourceId].ast, entry.pointer)
          })
        }))))
      }
    },

    /**
     * data.views.decoder
     *
     * selector returns (ast node definition, data reference) => Promise<value>
     */
    decoder: (0, _reselectTree.createLeaf)(["/views/referenceDeclarations", "/current/state", "/views/mappingKeys", "/info/allocations"], (referenceDeclarations, state, mappingKeys, allocations) => (definition, ref) => (0, _truffleDecoder.forEvmState)(definition, ref, {
      referenceDeclarations,
      state,
      mappingKeys,
      storageAllocations: allocations.storage,
      memoryAllocations: allocations.memory,
      calldataAllocations: allocations.calldata
    })),

    /*
     * data.views.userDefinedTypes
     */
    userDefinedTypes: {
      /*
       * data.views.userDefinedTypes.contractDefinitions
       * restrict to contracts only, and get their definitions
       */
      contractDefinitions: (0, _reselectTree.createLeaf)(["/info/userDefinedTypes", "/views/scopes/inlined"], (typeIds, scopes) => typeIds.map(id => scopes[id].definition).filter(node => node.nodeType === "ContractDefinition"))
    },

    /*
     * data.views.referenceDeclarations
     */
    referenceDeclarations: (0, _reselectTree.createLeaf)(["./scopes/inlined", "/info/userDefinedTypes"], (scopes, userDefinedTypes) => (0, _assign2.default)({}, ...userDefinedTypes.map(id => ({ [id]: scopes[id].definition })))),

    /**
     * data.views.mappingKeys
     */
    mappingKeys: (0, _reselectTree.createLeaf)(["/proc/mappedPaths", "/current/address", "/current/dummyAddress"], (mappedPaths, address, dummyAddress) => [].concat(...(0, _values2.default)((mappedPaths.byAddress[address || dummyAddress] || { byType: {} }).byType).map(({ bySlotAddress }) => (0, _values2.default)(bySlotAddress))).filter(slot => slot.key !== undefined))
  },

  /**
   * data.info
   */
  info: {
    /**
     * data.info.scopes (namespace)
     */
    scopes: {
      /**
       * data.info.scopes (selector)
       * the raw version is below; this version accounts for inheritance
       * NOTE: doesn't this selector really belong in data.views?  Yes.
       * But, since it's replacing the old data.info.scopes (which is now
       * data.info.scopes.raw), I didn't want to move it.
       */
      _: (0, _reselectTree.createLeaf)(["./raw", "/views/scopes/inlined/raw"], (scopes, inlined) => (0, _assign2.default)({}, ...(0, _entries2.default)(scopes).map(([id, scope]) => {
        let definition = inlined[id].definition;
        if (definition.nodeType !== "ContractDefinition") {
          return { [id]: scope };
        }
        //if we've reached this point, we should be dealing with a
        //contract, and specifically a contract -- not an interface or
        //library (those don't get "variables" entries in their scopes)
        debug("contract id %d", id);
        let newScope = (0, _extends3.default)({}, scope);
        //note that Solidity gives us the linearization in order from most
        //derived to most base, but we want most base to most derived;
        //annoyingly, reverse() is in-place, so we clone with slice() first
        let linearizedBaseContractsFromBase = definition.linearizedBaseContracts.slice().reverse();
        //now, we put it all together
        newScope.variables = [].concat(...linearizedBaseContractsFromBase.map(contractId => scopes[contractId].variables || []
        //we need the || [] because contracts with no state variables
        //have variables undefined rather than empty like you'd expect
        )).filter(variable => {
          //...except, HACK, let's filter out those constants we don't know
          //how to read.  they'll just clutter things up.
          debug("variable %O", variable);
          let definition = inlined[variable.id].definition;
          return !definition.constant || DecodeUtils.Definition.isSimpleConstant(definition.value);
        });

        return { [id]: newScope };
      }))),

      /*
       * data.info.scopes.raw
       */
      raw: (0, _reselectTree.createLeaf)(["/state"], state => state.info.scopes.byId)
    },

    /*
     * data.info.allocations
     */
    allocations: {
      /*
       * data.info.allocations.storage
       */
      storage: (0, _reselectTree.createLeaf)(["/state"], state => state.info.allocations.storage),

      /*
       * data.info.allocations.memory
       */
      memory: (0, _reselectTree.createLeaf)(["/state"], state => state.info.allocations.memory),

      /*
       * data.info.allocations.calldata
       */
      calldata: (0, _reselectTree.createLeaf)(["/state"], state => state.info.allocations.calldata)
    },

    /**
     * data.info.userDefinedTypes
     */
    userDefinedTypes: (0, _reselectTree.createLeaf)(["/state"], state => state.info.userDefinedTypes)
  },

  /**
   * data.proc
   */
  proc: {
    /**
     * data.proc.assignments
     */
    assignments: (0, _reselectTree.createLeaf)(["/state"], state => state.proc.assignments
    //note: this no longer fetches just the byId, but rather the whole
    //assignments object
    ),

    /*
     * data.proc.mappedPaths
     */
    mappedPaths: (0, _reselectTree.createLeaf)(["/state"], state => state.proc.mappedPaths),

    /**
     * data.proc.decodingKeys
     *
     * number of keys that are still decoding
     */
    decodingKeys: (0, _reselectTree.createLeaf)(["./mappedPaths"], mappedPaths => mappedPaths.decodingStarted)
  },

  /**
   * data.current
   */
  current: {
    /**
     * data.current.state
     */
    state: {
      /**
       * data.current.state.stack
       */
      stack: (0, _reselectTree.createLeaf)([_selectors4.default.current.state.stack], words => (words || []).map(word => DecodeUtils.Conversion.toBytes(word))),

      /**
       * data.current.state.memory
       */
      memory: (0, _reselectTree.createLeaf)([_selectors4.default.current.state.memory], words => DecodeUtils.Conversion.toBytes(words.join(""))),

      /**
       * data.current.state.calldata
       */
      calldata: (0, _reselectTree.createLeaf)([_selectors4.default.current.call], ({ data }) => DecodeUtils.Conversion.toBytes(data)),

      /**
       * data.current.state.storage
       */
      storage: (0, _reselectTree.createLeaf)([_selectors4.default.current.state.storage], mapping => (0, _assign2.default)({}, ...(0, _entries2.default)(mapping).map(([address, word]) => ({
        [`0x${address}`]: DecodeUtils.Conversion.toBytes(word)
      }))))
    },

    /**
     *
     * data.current.scope
     */
    scope: {
      /**
       * data.current.scope.id
       */
      id: (0, _reselectTree.createLeaf)([_selectors2.default.current.node], node => node.id)
    },

    /**
     * data.current.functionDepth
     */

    functionDepth: (0, _reselectTree.createLeaf)([_selectors6.default.current.functionDepth], identity),

    /**
     * data.current.address
     * Note: May be undefined (if in an initializer)
     */

    address: (0, _reselectTree.createLeaf)([_selectors4.default.current.call], call => call.address),

    /**
     * data.current.dummyAddress
     */

    dummyAddress: (0, _reselectTree.createLeaf)([_selectors4.default.current.creationDepth], identity),

    /**
     * data.current.identifiers (namespace)
     */
    identifiers: {
      /**
       * data.current.identifiers (selector)
       *
       * returns identifers and corresponding definition node ID
       */
      _: (0, _reselectTree.createLeaf)(["/views/scopes/inlined", "/current/scope"], (scopes, scope) => {
        let cur = scope.id;
        let variables = {};

        do {
          variables = (0, _assign2.default)(variables, ...(scopes[cur].variables || []).filter(v => v.name !== "") //exclude anonymous output params
          .filter(v => variables[v.name] == undefined).map(v => ({ [v.name]: v.id })));

          cur = scopes[cur].parentId;
        } while (cur != null);

        return variables;
      }),

      /**
       * data.current.identifiers.definitions
       *
       * current variable definitions
       */
      definitions: (0, _reselectTree.createLeaf)(["/views/scopes/inlined", "./_"], (scopes, identifiers) => (0, _assign2.default)({}, ...(0, _entries2.default)(identifiers).map(([identifier, id]) => {
        let { definition } = scopes[id];

        return { [identifier]: definition };
      }))),

      /**
       * data.current.identifiers.refs
       *
       * current variables' value refs
       */
      refs: (0, _reselectTree.createLeaf)(["/proc/assignments", "./_", _selectors6.default.current.functionDepth, //for pruning things too deep on stack
      "/current/address", //for contract variables
      "/current/dummyAddress" //for contract vars when in creation call
      ], (assignments, identifiers, currentDepth, address, dummyAddress) => (0, _assign2.default)({}, ...(0, _entries2.default)(identifiers).map(([identifier, astId]) => {
        //note: this needs tweaking for specials later
        let id;

        //first, check if it's a contract var
        if (address !== undefined) {
          let matchIds = (assignments.byAstId[astId] || []).filter(idHash => assignments.byId[idHash].address === address);
          if (matchIds.length > 0) {
            id = matchIds[0]; //there should only be one!
          }
        } else {
          let matchIds = (assignments.byAstId[astId] || []).filter(idHash => assignments.byId[idHash].dummyAddress === dummyAddress);
          if (matchIds.length > 0) {
            id = matchIds[0]; //again, there should only be one!
          }
        }

        //if not contract, it's local, so find the innermost
        //(but not beyond current depth)
        if (id === undefined) {
          let matchFrames = (assignments.byAstId[astId] || []).map(id => assignments.byId[id].stackframe).filter(stackframe => stackframe !== undefined);

          if (matchFrames.length > 0) {
            //this check isn't *really*
            //necessary, but may as well prevent stupid stuff
            let maxMatch = Math.min(currentDepth, Math.max(...matchFrames));
            id = (0, _helpers.stableKeccak256)({ astId, stackframe: maxMatch });
          }
        }

        //if we still didn't find it, oh well

        let { ref } = assignments.byId[id] || {};
        if (!ref) {
          return undefined;
        }

        return {
          [identifier]: ref
        };
      }))),

      /**
       * data.current.identifiers.decoded
       *
       * Returns an object with values as Promises
       */
      decoded: (0, _reselectTree.createLeaf)(["/views/decoder", "./definitions", "./refs"], (() => {
        var _ref = (0, _asyncToGenerator3.default)(function* (decode, definitions, refs) {
          debug("setting up keyedPromises");
          const keyedPromises = (0, _entries2.default)(refs).map((() => {
            var _ref2 = (0, _asyncToGenerator3.default)(function* ([identifier, ref]) {
              return {
                [identifier]: yield decode(definitions[identifier], ref)
              };
            });

            return function (_x4) {
              return _ref2.apply(this, arguments);
            };
          })());
          debug("set up keyedPromises");
          const keyedResults = yield _promise2.default.all(keyedPromises);
          debug("got keyedResults");
          return DecodeUtils.Conversion.cleanContainers((0, _assign2.default)({}, ...keyedResults));
        });

        return function (_x, _x2, _x3) {
          return _ref.apply(this, arguments);
        };
      })())
    }
  },

  /**
   * data.next
   */
  next: {
    /**
     * data.next.state
     */
    state: {
      /**
       * data.next.state.stack
       */
      stack: (0, _reselectTree.createLeaf)([_selectors4.default.next.state.stack], words => (words || []).map(word => DecodeUtils.Conversion.toBytes(word)))
    }
  }
});

exports.default = data;

/***/ }),
/* 22 */
/***/ (function(module, exports) {

module.exports = require("json-pointer");

/***/ }),
/* 23 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/keys");

/***/ }),
/* 24 */
/***/ (function(module, exports) {

module.exports = require("truffle-decoder");

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(2);

var _selectors = __webpack_require__(10);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(9);

var _selectors4 = _interopRequireDefault(_selectors3);

var _selectors5 = __webpack_require__(15);

var _selectors6 = _interopRequireDefault(_selectors5);

var _selectors7 = __webpack_require__(16);

var _selectors8 = _interopRequireDefault(_selectors7);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:controller:sagas");

/**
 * @private
 */
const identity = x => x;

/**
 * controller
 */
const controller = (0, _reselectTree.createSelectorTree)({
  /**
   * controller.state
   */
  state: state => state.controller,
  /**
   * controller.current
   */
  current: {
    /**
     * controller.current.functionDepth
     */
    functionDepth: (0, _reselectTree.createLeaf)([_selectors4.default.current.functionDepth], identity),

    /**
     * controller.current.executionContext
     */
    executionContext: (0, _reselectTree.createLeaf)([_selectors2.default.current.call], identity),

    /**
     * controller.current.willJump
     */
    willJump: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.isJump], identity),

    /**
     * controller.current.location
     */
    location: {
      /**
       * controller.current.location.sourceRange
       */
      sourceRange: (0, _reselectTree.createLeaf)([_selectors4.default.current.sourceRange], identity),

      /**
       * controller.current.location.source
       */
      source: (0, _reselectTree.createLeaf)([_selectors4.default.current.source], identity),

      /**
       * controller.current.location.node
       */
      node: (0, _reselectTree.createLeaf)([_selectors6.default.current.node], identity),

      /**
       * controller.current.location.isMultiline
       */
      isMultiline: (0, _reselectTree.createLeaf)([_selectors4.default.current.isMultiline], identity)
    }
  },

  /**
   * controller.breakpoints
   */
  breakpoints: (0, _reselectTree.createLeaf)(["./state"], state => state.breakpoints),

  /**
   * controller.isStepping
   */
  isStepping: (0, _reselectTree.createLeaf)(["./state"], state => state.isStepping),

  /**
   * controller.finished
   */
  finished: (0, _reselectTree.createLeaf)([_selectors8.default.finished], identity)
});

exports.default = controller;

/***/ }),
/* 26 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/promise");

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = __webpack_require__(23);

var _keys2 = _interopRequireDefault(_keys);

exports.getRange = getRange;
exports.rangeNodes = rangeNodes;
exports.findRange = findRange;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _nodeIntervalTree = __webpack_require__(44);

var _nodeIntervalTree2 = _interopRequireDefault(_nodeIntervalTree);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:ast:map");

/**
 * @private
 */
function getRange(node) {
  // src: "<start>:<length>:<_>"
  // returns [start, end]
  let [start, length] = node.src.split(":").slice(0, 2).map(i => parseInt(i));

  return [start, start + length];
}

/**
 * @private
 */
function rangeNodes(node, pointer = "") {
  if (node instanceof Array) {
    return [].concat(...node.map((sub, i) => rangeNodes(sub, `${pointer}/${i}`)));
  } else if (node instanceof Object) {
    let results = [];

    if (node.src) {
      results.push({ pointer, range: getRange(node) });
    }

    return results.concat(...(0, _keys2.default)(node).map(key => rangeNodes(node[key], `${pointer}/${key}`)));
  } else {
    return [];
  }
}

/**
 * @private
 */
function findRange(node, sourceStart, sourceLength) {
  let ranges = rangeNodes(node);
  let tree = new _nodeIntervalTree2.default();

  ranges.forEach(({ range, pointer }) => {
    let [start, end] = range;

    tree.insert(start, end, { range, pointer });
  });

  let sourceEnd = sourceStart + sourceLength;

  let overlapping = tree.search(sourceStart, sourceEnd);

  // find nodes that fully contain requested range,
  // return longest pointer
  return overlapping.filter(({ range }) => sourceStart >= range[0] && sourceEnd <= range[1]).map(({ pointer }) => pointer).reduce((a, b) => a.length > b.length ? a : b, "");
}

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.scope = scope;
exports.declare = declare;
exports.assign = assign;
exports.mapPathAndAssign = mapPathAndAssign;
exports.mapKeyDecoding = mapKeyDecoding;
exports.reset = reset;
exports.learnAddress = learnAddress;
exports.defineType = defineType;
exports.allocate = allocate;
const SCOPE = exports.SCOPE = "SCOPE";
function scope(id, pointer, parentId, sourceId) {
  return {
    type: SCOPE,
    id,
    pointer,
    parentId,
    sourceId
  };
}

const DECLARE = exports.DECLARE = "DECLARE_VARIABLE";
function declare(node) {
  return {
    type: DECLARE,
    node
  };
}

const ASSIGN = exports.ASSIGN = "ASSIGN";
function assign(assignments) {
  return {
    type: ASSIGN,
    assignments
  };
}

const MAP_PATH_AND_ASSIGN = exports.MAP_PATH_AND_ASSIGN = "MAP_PATH_AND_ASSIGN";
function mapPathAndAssign(address, slot, assignments, typeIdentifier, parentType) {
  return {
    type: MAP_PATH_AND_ASSIGN,
    address,
    slot,
    assignments,
    typeIdentifier,
    parentType
  };
}

const MAP_KEY_DECODING = exports.MAP_KEY_DECODING = "MAP_KEY_DECODING";
function mapKeyDecoding(started) {
  return {
    type: MAP_KEY_DECODING,
    started
  };
}

const RESET = exports.RESET = "DATA_RESET";
function reset() {
  return { type: RESET };
}

const LEARN_ADDRESS = exports.LEARN_ADDRESS = "LEARN_ADDRESS";
function learnAddress(dummyAddress, address) {
  return {
    type: LEARN_ADDRESS,
    dummyAddress,
    address
  };
}

const DEFINE_TYPE = exports.DEFINE_TYPE = "DEFINE_TYPE";
function defineType(node) {
  return {
    type: DEFINE_TYPE,
    node
  };
}

const ALLOCATE = exports.ALLOCATE = "ALLOCATE";
function allocate(storage, memory, calldata) {
  return {
    type: ALLOCATE,
    storage,
    memory,
    calldata
  };
}

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addContext = addContext;
exports.addInstance = addInstance;
exports.begin = begin;
exports.callstackSaga = callstackSaga;
exports.reset = reset;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(4);

var _helpers = __webpack_require__(1);

var _truffleDecodeUtils = __webpack_require__(3);

var DecodeUtils = _interopRequireWildcard(_truffleDecodeUtils);

var _actions = __webpack_require__(11);

var _actions2 = __webpack_require__(30);

var actions = _interopRequireWildcard(_actions2);

var _selectors = __webpack_require__(10);

var _selectors2 = _interopRequireDefault(_selectors);

var _sagas = __webpack_require__(17);

var data = _interopRequireWildcard(_sagas);

var _sagas2 = __webpack_require__(12);

var trace = _interopRequireWildcard(_sagas2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:evm:sagas");

/**
 * Adds EVM bytecode context
 *
 * @return {string} ID (0x-prefixed keccak of binary)
 */
function* addContext(contractName, { address, binary }, compiler) {
  const raw = binary || address;
  const context = (0, _helpers.keccak256)(raw);

  yield (0, _effects.put)(actions.addContext(contractName, raw, compiler));

  if (binary) {
    yield (0, _effects.put)(actions.addBinary(context, binary));
  }

  return context;
}

/**
 * Adds known deployed instance of binary at address
 *
 * @param {string} binary - may be undefined (e.g. precompiles)
 * @return {string} ID (0x-prefixed keccak of binary)
 */
function* addInstance(address, binary) {
  let search = yield (0, _effects.select)(_selectors2.default.info.binaries.search);
  let { context } = search(binary);

  // in case binary is unknown, add context for address
  if (!context) {
    context = yield* addContext(undefined, { address }, undefined);
  }

  yield (0, _effects.put)(actions.addInstance(address, context, binary));

  return context;
}

function* begin({ address, binary, data }) {
  if (address) {
    yield (0, _effects.put)(actions.call(address, data));
  } else {
    yield (0, _effects.put)(actions.create(binary));
  }
}

function* tickSaga() {
  debug("got TICK");

  yield* callstackSaga();
  yield* trace.signalTickSagaCompletion();
}

function* callstackSaga() {
  if (yield (0, _effects.select)(_selectors2.default.current.step.isCall)) {
    debug("got call");
    let address = yield (0, _effects.select)(_selectors2.default.current.step.callAddress);
    let data = yield (0, _effects.select)(_selectors2.default.current.step.callData);

    debug("calling address %s", address);

    // if there is no binary (e.g. in the case of precompiled contracts),
    // then there will be no trace steps for the called code, and so we
    // shouldn't tell the debugger that we're entering another execution
    // context
    if (yield (0, _effects.select)(_selectors2.default.current.step.callsPrecompile)) {
      return;
    }

    yield (0, _effects.put)(actions.call(address, data));
  } else if (yield (0, _effects.select)(_selectors2.default.current.step.isCreate)) {
    debug("got create");
    let binary = yield (0, _effects.select)(_selectors2.default.current.step.createBinary);

    yield (0, _effects.put)(actions.create(binary));
  } else if (yield (0, _effects.select)(_selectors2.default.current.step.isHalting)) {
    debug("got return");

    let callstack = yield (0, _effects.select)(_selectors2.default.current.callstack);

    //if the program's not ending, and we just returned from a constructor,
    //learn the address of what we just initialized
    //(do this before we put the return action to avoid off-by-one error)
    if (callstack.length > 1 && callstack[callstack.length - 1].address === undefined) {
      let dummyAddress = yield (0, _effects.select)(_selectors2.default.current.creationDepth);
      debug("dummyAddress %d", dummyAddress);

      //NOTE: the following logic, for getting the created address, really
      //belongs in a selector.  However, every time I try to make it a
      //selector, I get mysterious error messages.  So, we'll do it ourselves
      //in the saga instead.

      let stack = yield (0, _effects.select)(_selectors2.default.next.state.stack);
      let createdAddress = DecodeUtils.Conversion.toAddress(stack[stack.length - 1]);
      debug("createdAddress %s", createdAddress);

      yield* data.learnAddressSaga(dummyAddress, createdAddress);
      debug("address learnt");
    }

    yield (0, _effects.put)(actions.returnCall());
  }
}

function* reset() {
  yield (0, _effects.put)(actions.reset());
}

function* saga() {
  yield (0, _effects.takeEvery)(_actions.TICK, tickSaga);
}

exports.default = (0, _helpers.prefixName)("evm", saga);

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addContext = addContext;
exports.addBinary = addBinary;
exports.addInstance = addInstance;
exports.call = call;
exports.create = create;
exports.returnCall = returnCall;
exports.reset = reset;
const ADD_CONTEXT = exports.ADD_CONTEXT = "EVM_ADD_CONTEXT";
function addContext(contractName, raw, compiler) {
  return {
    type: ADD_CONTEXT,
    contractName,
    raw,
    compiler
  };
}

const ADD_BINARY = exports.ADD_BINARY = "EVM_ADD_BINARY";
function addBinary(context, binary) {
  return {
    type: ADD_BINARY,
    context,
    binary
  };
}

const ADD_INSTANCE = exports.ADD_INSTANCE = "EVM_ADD_INSTANCE";
function addInstance(address, context, binary) {
  return {
    type: ADD_INSTANCE,
    address,
    context,
    binary
  };
}

const CALL = exports.CALL = "CALL";
function call(address, data) {
  return {
    type: CALL,
    address,
    data
  };
}

const CREATE = exports.CREATE = "CREATE";
function create(binary) {
  return {
    type: CREATE,
    binary
  };
}

const RETURN = exports.RETURN = "RETURN";
function returnCall() {
  return {
    type: RETURN
  };
}

const RESET = exports.RESET = "EVM_RESET";
function reset() {
  return { type: RESET };
}

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addSource = addSource;
exports.addSourceMap = addSourceMap;
exports.reset = reset;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(4);

var _helpers = __webpack_require__(1);

var _actions = __webpack_require__(32);

var actions = _interopRequireWildcard(_actions);

var _actions2 = __webpack_require__(11);

var _sagas = __webpack_require__(12);

var trace = _interopRequireWildcard(_sagas);

var _selectors = __webpack_require__(9);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:solidity:sagas");

function* addSource(source, sourcePath, ast) {
  yield (0, _effects.put)(actions.addSource(source, sourcePath, ast));
}

function* addSourceMap(binary, sourceMap) {
  yield (0, _effects.put)(actions.addSourceMap(binary, sourceMap));
}

function* tickSaga() {
  debug("got TICK");

  yield* functionDepthSaga();
  yield* trace.signalTickSagaCompletion();
}

function* functionDepthSaga() {
  if (yield (0, _effects.select)(_selectors2.default.current.willJump)) {
    let jumpDirection = yield (0, _effects.select)(_selectors2.default.current.jumpDirection);
    yield (0, _effects.put)(actions.jump(jumpDirection));
  } else if (yield (0, _effects.select)(_selectors2.default.current.willCall)) {
    //we have several cases here:
    //1. precompile -- *don't* put any jump
    //2. workaround case -- put a double jump (see below)
    //3. general case -- put a single jump as expected

    debug("about to call");
    if (yield (0, _effects.select)(_selectors2.default.current.callsPrecompile)) {
      //call to precompile; do nothing
    } else if ((yield (0, _effects.select)(_selectors2.default.current.needsFunctionDepthWorkaround)) && (yield (0, _effects.select)(_selectors2.default.current.isContractCall))) {
      //all these parentheses are necessary
      //HACK WORKAROUND
      //because of the problem in solc <0.5.1 where contract method calls
      //essentially return twice, we compensate by putting *two* inward jumps
      //for such a call.
      //Note that this won't work if the contract method was previously placed
      //in a function variable!  Those will continue to screw things up!  But
      //if a contract call is being made directly, we can detect that.
      //Of course, all of this should work fine as of solidity 0.5.1, with no
      //workaround necessary; this branch should only get take on old
      //contracts.
      debug("workaround invoked!");
      yield (0, _effects.put)(actions.jump("2"));
    } else {
      //an ordinary call, not to a precompile & with no workaround needed
      yield (0, _effects.put)(actions.jump("i"));
    }
  } else if (yield (0, _effects.select)(_selectors2.default.current.willCreate)) {
    //this case, thankfully, needs no further breakdown
    yield (0, _effects.put)(actions.jump("i"));
  } else if (yield (0, _effects.select)(_selectors2.default.current.willReturn)) {
    yield (0, _effects.put)(actions.jump("o"));
  }
}

function* reset() {
  yield (0, _effects.put)(actions.reset());
}

function* saga() {
  yield (0, _effects.takeEvery)(_actions2.TICK, tickSaga);
}

exports.default = (0, _helpers.prefixName)("solidity", saga);

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addSource = addSource;
exports.addSourceMap = addSourceMap;
exports.jump = jump;
exports.reset = reset;
const ADD_SOURCE = exports.ADD_SOURCE = "SOLIDITY_ADD_SOURCE";
function addSource(source, sourcePath, ast) {
  return {
    type: ADD_SOURCE,
    source,
    sourcePath,
    ast
  };
}

const ADD_SOURCEMAP = exports.ADD_SOURCEMAP = "SOLIDITY_ADD_SOURCEMAP";
function addSourceMap(binary, sourceMap) {
  return {
    type: ADD_SOURCEMAP,
    binary,
    sourceMap
  };
}

const JUMP = exports.JUMP = "JUMP";
function jump(jumpDirection) {
  return {
    type: JUMP,
    jumpDirection
  };
}

const RESET = exports.RESET = "SOLIDITY_RESET";
function reset() {
  return { type: RESET };
}

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

var Debugger = __webpack_require__(34).default;

module.exports = Debugger;



/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _asyncToGenerator2 = __webpack_require__(13);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _session = __webpack_require__(35);

var _session2 = _interopRequireDefault(_session);

var _reselectTree = __webpack_require__(2);

var _selectors = __webpack_require__(21);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(15);

var _selectors4 = _interopRequireDefault(_selectors3);

var _selectors5 = __webpack_require__(16);

var _selectors6 = _interopRequireDefault(_selectors5);

var _selectors7 = __webpack_require__(10);

var _selectors8 = _interopRequireDefault(_selectors7);

var _selectors9 = __webpack_require__(9);

var _selectors10 = _interopRequireDefault(_selectors9);

var _selectors11 = __webpack_require__(63);

var _selectors12 = _interopRequireDefault(_selectors11);

var _selectors13 = __webpack_require__(25);

var _selectors14 = _interopRequireDefault(_selectors13);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger");

var expect = {
  options: function (options, expected_keys) {
    expected_keys.forEach(function (key) {
      if (options[key] == null) {
        throw new Error(`Expected parameter "${key}" not passed to function.`);
      }
    });
  },

  one: function (options, expected_keys) {
    var found = [];

    expected_keys.forEach(function (key) {
      if (options[key] != null) {
        found.push(1);
      } else {
        found.push(0);
      }
    });

    var total = found.reduce(function (t, value) {
      return t + value;
    });

    if (total >= 1) return;

    throw new Error(`Expected one of the following parameters, but found none: ${expected_keys.join(", ")}`);
  }

  /**
   * @example
   * let session = Debugger
   *   .forTx(<txHash>, {
   *     contracts: [<contract obj>, ...],
   *     provider: <provider instance>
   *   })
   *   .connect();
   */
};class Debugger {
  /**
   * @param {Session} session - debugger session
   * @private
   */
  constructor(session) {
    /**
     * @private
     */
    this._session = session;
  }

  /**
   * Instantiates a Debugger for a given transaction hash.
   *
   * @param {String} txHash - transaction hash with leading "0x"
   * @param {{contracts: Array<Contract>, files: Array<String>, provider: EthersJSProvider}} options -
   * @return {Debugger} instance
   */
  static forTx(txHash, options = {}) {
    var _this = this;

    return (0, _asyncToGenerator3.default)(function* () {
      expect.options(options, ["contracts", "provider"]);

      let session = new _session2.default(options.contracts, options.files, txHash, options.provider);

      try {
        yield session.ready();
      } catch (e) {
        throw e;
      }

      return new _this(session);
    })();
  }

  /**
   * Connects to the instantiated Debugger.
   *
   * @return {Session} session instance
   */
  connect() {
    return this._session;
  }

  /**
   * Exported selectors
   *
   * See individual selector docs for full listing
   *
   * @example
   * Debugger.selectors.ast.current.tree
   *
   * @example
   * Debugger.selectors.solidity.current.instruction
   *
   * @example
   * Debugger.selectors.trace.steps
   */
  static get selectors() {
    return (0, _reselectTree.createNestedSelector)({
      ast: _selectors4.default,
      data: _selectors2.default,
      trace: _selectors6.default,
      evm: _selectors8.default,
      solidity: _selectors10.default,
      session: _selectors12.default,
      controller: _selectors14.default
    });
  }
}

exports.default = Debugger; /**
                             * @typedef {Object} Contract
                             * @property {string} contractName contract name
                             * @property {string} source solidity source code
                             * @property {string} sourcePath path to source file
                             * @property {string} binary 0x-prefixed hex string with create bytecode
                             * @property {string} sourceMap solidity source map for create bytecode
                             * @property {Object} ast Abstract Syntax Tree from Solidity
                             * @property {string} deployedBinary 0x-prefixed compiled binary (on chain)
                             * @property {string} deployedSourceMap solidity source map for on-chain bytecode
                             */

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _values = __webpack_require__(19);

var _values2 = _interopRequireDefault(_values);

var _promise = __webpack_require__(26);

var _promise2 = _interopRequireDefault(_promise);

var _asyncToGenerator2 = __webpack_require__(13);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _store = __webpack_require__(36);

var _store2 = _interopRequireDefault(_store);

var _actions = __webpack_require__(20);

var controller = _interopRequireWildcard(_actions);

var _actions2 = __webpack_require__(14);

var actions = _interopRequireWildcard(_actions2);

var _selectors = __webpack_require__(21);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(25);

var _selectors4 = _interopRequireDefault(_selectors3);

var _sagas = __webpack_require__(48);

var _sagas2 = _interopRequireDefault(_sagas);

var _reducers = __webpack_require__(56);

var _reducers2 = _interopRequireDefault(_reducers);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:session"); //eslint-disable-line no-unused-vars

/**
 * Debugger Session
 */
class Session {
  /**
   * @param {Array<Contract>} contracts - contract definitions
   * @param {Array<String>} files - array of filenames for sourceMap indexes
   * @param {string} txHash - transaction hash
   * @param {EthersJsProvider} provider - ethers.js provider
   * @private
   */
  constructor(contracts, files, txHash, provider) {
    /**
     * @private
     */
    this._store = (0, _store2.default)(_reducers2.default, _sagas2.default);

    let { contexts, sources } = Session.normalize(contracts, files);

    // record contracts
    this._store.dispatch(actions.recordContracts(contexts, sources));

    this._store.dispatch(actions.start(txHash, provider));
  }

  ready() {
    var _this = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return new _promise2.default(function (accept, reject) {
        _this._store.subscribe(function () {
          if (_this.state.session.status == "ACTIVE") {
            accept();
          } else if (typeof _this.state.session.status == "object") {
            reject(_this.state.session.status.error);
          }
        });
      });
    })();
  }

  /**
   * Split up artifacts into "contexts" and "sources", dividing artifact
   * data into appropriate buckets.
   *
   * Multiple contracts can be defined in the same source file, but have
   * different bytecodes.
   *
   * This iterates over the contracts and collects binaries separately
   * from sources, using the optional `files` argument to force
   * source ordering.
   * @private
   */
  static normalize(contracts, files = null) {
    let sourcesByPath = {};
    let contexts = [];
    let sources;

    for (let contract of contracts) {
      let {
        contractName,
        binary,
        sourceMap,
        deployedBinary,
        deployedSourceMap,
        sourcePath,
        source,
        ast,
        compiler
      } = contract;

      debug("sourceMap %o", sourceMap);
      debug("compiler %o", compiler);

      sourcesByPath[sourcePath] = { sourcePath, source, ast };

      if (binary && binary != "0x") {
        contexts.push({
          contractName,
          binary,
          sourceMap
        });
      }

      if (deployedBinary && deployedBinary != "0x") {
        contexts.push({
          contractName,
          binary: deployedBinary,
          sourceMap: deployedSourceMap,
          compiler
        });
      }
    }

    if (!files) {
      sources = (0, _values2.default)(sourcesByPath);
    } else {
      sources = files.map(file => sourcesByPath[file]);
    }

    return { contexts, sources };
  }

  get state() {
    return this._store.getState();
  }

  view(selector) {
    return selector(this.state);
  }

  dispatch(action) {
    var _this2 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      _this2._store.dispatch(action);

      return true;
    })();
  }

  interrupt() {
    var _this3 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return _this3.dispatch(controller.interrupt());
    })();
  }

  doneStepping(stepperAction) {
    var _this4 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return new _promise2.default(function (resolve) {
        let hasStarted = false;
        let hasResolved = false;
        const unsubscribe = _this4._store.subscribe(function () {
          const isStepping = _this4.view(_selectors4.default.isStepping);

          if (isStepping && !hasStarted) {
            hasStarted = true;
            debug("heard step start");
            return;
          }

          if (!isStepping && hasStarted && !hasResolved) {
            hasResolved = true;
            debug("heard step stop");
            unsubscribe();
            resolve(true);
          }
        });
        _this4.dispatch(stepperAction);
      });
    })();
  }

  advance(count = 1) {
    var _this5 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return yield _this5.doneStepping(controller.advance(count));
    })();
  }

  stepNext() {
    var _this6 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return yield _this6.doneStepping(controller.stepNext());
    })();
  }

  stepOver() {
    var _this7 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return yield _this7.doneStepping(controller.stepOver());
    })();
  }

  stepInto() {
    var _this8 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return yield _this8.doneStepping(controller.stepInto());
    })();
  }

  stepOut() {
    var _this9 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return yield _this9.doneStepping(controller.stepOut());
    })();
  }

  reset() {
    var _this10 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return yield _this10.doneStepping(controller.reset());
    })();
  }

  continueUntilBreakpoint() {
    var _this11 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return yield _this11.doneStepping(controller.continueUntilBreakpoint());
    })();
  }

  addBreakpoint(breakpoint) {
    var _this12 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return _this12.dispatch(controller.addBreakpoint(breakpoint));
    })();
  }

  removeBreakpoint(breakpoint) {
    var _this13 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return _this13.dispatch(controller.removeBreakpoint(breakpoint));
    })();
  }

  removeAllBreakpoints() {
    var _this14 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return _this14.dispatch(controller.removeAllBreakpoints());
    })();
  }

  decodeReady() {
    var _this15 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return new _promise2.default(function (resolve) {
        let haveResolved = false;
        const unsubscribe = _this15._store.subscribe(function () {
          const subscriptionDecodingStarted = _this15.view(_selectors2.default.proc.decodingKeys);

          debug("following decoding started: %d", subscriptionDecodingStarted);

          if (subscriptionDecodingStarted <= 0 && !haveResolved) {
            haveResolved = true;
            unsubscribe();
            resolve();
          }
        });

        const decodingStarted = _this15.view(_selectors2.default.proc.decodingKeys);

        debug("initial decoding started: %d", decodingStarted);

        if (decodingStarted <= 0) {
          haveResolved = true;
          unsubscribe();
          resolve();
        }
      });
    })();
  }

  variable(name) {
    var _this16 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      yield _this16.decodeReady();

      const definitions = _this16.view(_selectors2.default.current.identifiers.definitions);
      const refs = _this16.view(_selectors2.default.current.identifiers.refs);

      const decode = _this16.view(_selectors2.default.views.decoder);
      return yield decode(definitions[name], refs[name]);
    })();
  }

  variables() {
    var _this17 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      debug("awaiting decodeReady");
      yield _this17.decodeReady();
      debug("decode now ready");

      return yield _this17.view(_selectors2.default.current.identifiers.decoded);
      debug("got variables");
    })();
  }
}
exports.default = Session;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// if (process.env.NODE_ENV === "production") {
module.exports = __webpack_require__(37);
// } else if (process.env.NODE_ENV === "test") {
//   module.exports = require("./test");
// } else {
//   module.exports = require("./development");
// }

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _common = __webpack_require__(38);

var _common2 = _interopRequireDefault(_common);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _common2.default;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = __webpack_require__(5);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(8);

var _assign2 = _interopRequireDefault(_assign);

exports.abbreviateValues = abbreviateValues;
exports.default = configureStore;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _redux = __webpack_require__(6);

var _reduxSaga = __webpack_require__(39);

var _reduxSaga2 = _interopRequireDefault(_reduxSaga);

var _reduxCliLogger = __webpack_require__(40);

var _reduxCliLogger2 = _interopRequireDefault(_reduxCliLogger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:store:common");
const reduxDebug = (0, _debug2.default)("debugger:redux");

function abbreviateValues(value, options = {}, depth = 0) {
  options.stringLimit = options.stringLimit || 66;
  options.arrayLimit = options.arrayLimit || 8;
  options.recurseLimit = options.recurseLimit || 4;

  if (depth > options.recurseLimit) {
    return "...";
  }

  const recurse = child => abbreviateValues(child, options, depth + 1);

  if (value instanceof Array) {
    if (value.length > options.arrayLimit) {
      value = [...value.slice(0, options.arrayLimit / 2), "...", ...value.slice(value.length - options.arrayLimit / 2 + 1)];
    }

    return value.map(recurse);
  } else if (value instanceof Object) {
    return (0, _assign2.default)({}, ...(0, _entries2.default)(value).map(([k, v]) => ({ [recurse(k)]: recurse(v) })));
  } else if (typeof value === "string" && value.length > options.stringLimit) {
    let inner = "...";
    let extractAmount = (options.stringLimit - inner.length) / 2;
    let leading = value.slice(0, Math.ceil(extractAmount));
    let trailing = value.slice(value.length - Math.floor(extractAmount));
    return `${leading}${inner}${trailing}`;
  } else {
    return value;
  }
}

function configureStore(reducer, saga, initialState, composeEnhancers) {
  const sagaMiddleware = (0, _reduxSaga2.default)();

  if (!composeEnhancers) {
    composeEnhancers = _redux.compose;
  }

  const loggerMiddleware = (0, _reduxCliLogger2.default)({
    log: reduxDebug,
    stateTransformer: state => abbreviateValues(state, {
      arrayLimit: 4,
      recurseLimit: 3
    }),
    actionTransformer: abbreviateValues
  });

  let store = (0, _redux.createStore)(reducer, initialState, composeEnhancers((0, _redux.applyMiddleware)(sagaMiddleware, loggerMiddleware)));

  sagaMiddleware.run(saga);

  return store;
}

/***/ }),
/* 39 */
/***/ (function(module, exports) {

module.exports = require("redux-saga");

/***/ }),
/* 40 */
/***/ (function(module, exports) {

module.exports = require("redux-cli-logger");

/***/ }),
/* 41 */
/***/ (function(module, exports) {

module.exports = require("json-stable-stringify");

/***/ }),
/* 42 */
/***/ (function(module, exports) {

module.exports = require("truffle-solidity-utils");

/***/ }),
/* 43 */
/***/ (function(module, exports) {

module.exports = require("truffle-code-utils");

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// An augmented AVL Tree where each node maintains a list of records and their search intervals.
// Record is composed of an interval and its underlying data, sent by a client. This allows the
// interval tree to have the same interval inserted multiple times, as long its data is different.
// Both insertion and deletion require O(log n) time. Searching requires O(k*logn) time, where `k`
// is the number of intervals in the output list.
Object.defineProperty(exports, "__esModule", { value: true });
var isSame = __webpack_require__(45);
function height(node) {
    if (node === undefined) {
        return -1;
    }
    else {
        return node.height;
    }
}
var Node = /** @class */ (function () {
    function Node(intervalTree, record) {
        this.intervalTree = intervalTree;
        this.records = [];
        this.height = 0;
        this.key = record.low;
        this.max = record.high;
        // Save the array of all records with the same key for this node
        this.records.push(record);
    }
    // Gets the highest record.high value for this node
    Node.prototype.getNodeHigh = function () {
        var high = this.records[0].high;
        for (var i = 1; i < this.records.length; i++) {
            if (this.records[i].high > high) {
                high = this.records[i].high;
            }
        }
        return high;
    };
    // Updates height value of the node. Called during insertion, rebalance, removal
    Node.prototype.updateHeight = function () {
        this.height = Math.max(height(this.left), height(this.right)) + 1;
    };
    // Updates the max value of all the parents after inserting into already existing node, as well as
    // removing the node completely or removing the record of an already existing node. Starts with
    // the parent of an affected node and bubbles up to root
    Node.prototype.updateMaxOfParents = function () {
        if (this === undefined) {
            return;
        }
        var thisHigh = this.getNodeHigh();
        if (this.left !== undefined && this.right !== undefined) {
            this.max = Math.max(Math.max(this.left.max, this.right.max), thisHigh);
        }
        else if (this.left !== undefined && this.right === undefined) {
            this.max = Math.max(this.left.max, thisHigh);
        }
        else if (this.left === undefined && this.right !== undefined) {
            this.max = Math.max(this.right.max, thisHigh);
        }
        else {
            this.max = thisHigh;
        }
        if (this.parent) {
            this.parent.updateMaxOfParents();
        }
    };
    /*
    Left-Left case:
  
           z                                      y
          / \                                   /   \
         y   T4      Right Rotate (z)          x     z
        / \          - - - - - - - - ->       / \   / \
       x   T3                                T1 T2 T3 T4
      / \
    T1   T2
  
    Left-Right case:
  
         z                               z                           x
        / \                             / \                        /   \
       y   T4  Left Rotate (y)         x  T4  Right Rotate(z)     y     z
      / \      - - - - - - - - ->     / \      - - - - - - - ->  / \   / \
    T1   x                           y  T3                      T1 T2 T3 T4
        / \                         / \
      T2   T3                      T1 T2
    */
    // Handles Left-Left case and Left-Right case after rebalancing AVL tree
    Node.prototype._updateMaxAfterRightRotate = function () {
        var parent = this.parent;
        var left = parent.left;
        // Update max of left sibling (x in first case, y in second)
        var thisParentLeftHigh = left.getNodeHigh();
        if (left.left === undefined && left.right !== undefined) {
            left.max = Math.max(thisParentLeftHigh, left.right.max);
        }
        else if (left.left !== undefined && left.right === undefined) {
            left.max = Math.max(thisParentLeftHigh, left.left.max);
        }
        else if (left.left === undefined && left.right === undefined) {
            left.max = thisParentLeftHigh;
        }
        else {
            left.max = Math.max(Math.max(left.left.max, left.right.max), thisParentLeftHigh);
        }
        // Update max of itself (z)
        var thisHigh = this.getNodeHigh();
        if (this.left === undefined && this.right !== undefined) {
            this.max = Math.max(thisHigh, this.right.max);
        }
        else if (this.left !== undefined && this.right === undefined) {
            this.max = Math.max(thisHigh, this.left.max);
        }
        else if (this.left === undefined && this.right === undefined) {
            this.max = thisHigh;
        }
        else {
            this.max = Math.max(Math.max(this.left.max, this.right.max), thisHigh);
        }
        // Update max of parent (y in first case, x in second)
        parent.max = Math.max(Math.max(parent.left.max, parent.right.max), parent.getNodeHigh());
    };
    /*
    Right-Right case:
  
      z                               y
     / \                            /   \
    T1  y     Left Rotate(z)       z     x
       / \   - - - - - - - ->     / \   / \
      T2  x                      T1 T2 T3 T4
         / \
        T3 T4
  
    Right-Left case:
  
       z                            z                            x
      / \                          / \                         /   \
     T1  y   Right Rotate (y)     T1  x      Left Rotate(z)   z     y
        / \  - - - - - - - - ->      / \   - - - - - - - ->  / \   / \
       x  T4                        T2  y                   T1 T2 T3 T4
      / \                              / \
    T2   T3                           T3 T4
    */
    // Handles Right-Right case and Right-Left case in rebalancing AVL tree
    Node.prototype._updateMaxAfterLeftRotate = function () {
        var parent = this.parent;
        var right = parent.right;
        // Update max of right sibling (x in first case, y in second)
        var thisParentRightHigh = right.getNodeHigh();
        if (right.left === undefined && right.right !== undefined) {
            right.max = Math.max(thisParentRightHigh, right.right.max);
        }
        else if (right.left !== undefined && right.right === undefined) {
            right.max = Math.max(thisParentRightHigh, right.left.max);
        }
        else if (right.left === undefined && right.right === undefined) {
            right.max = thisParentRightHigh;
        }
        else {
            right.max = Math.max(Math.max(right.left.max, right.right.max), thisParentRightHigh);
        }
        // Update max of itself (z)
        var thisHigh = this.getNodeHigh();
        if (this.left === undefined && this.right !== undefined) {
            this.max = Math.max(thisHigh, this.right.max);
        }
        else if (this.left !== undefined && this.right === undefined) {
            this.max = Math.max(thisHigh, this.left.max);
        }
        else if (this.left === undefined && this.right === undefined) {
            this.max = thisHigh;
        }
        else {
            this.max = Math.max(Math.max(this.left.max, this.right.max), thisHigh);
        }
        // Update max of parent (y in first case, x in second)
        parent.max = Math.max(Math.max(parent.left.max, right.max), parent.getNodeHigh());
    };
    Node.prototype._leftRotate = function () {
        var rightChild = this.right;
        rightChild.parent = this.parent;
        if (rightChild.parent === undefined) {
            this.intervalTree.root = rightChild;
        }
        else {
            if (rightChild.parent.left === this) {
                rightChild.parent.left = rightChild;
            }
            else if (rightChild.parent.right === this) {
                rightChild.parent.right = rightChild;
            }
        }
        this.right = rightChild.left;
        if (this.right !== undefined) {
            this.right.parent = this;
        }
        rightChild.left = this;
        this.parent = rightChild;
        this.updateHeight();
        rightChild.updateHeight();
    };
    Node.prototype._rightRotate = function () {
        var leftChild = this.left;
        leftChild.parent = this.parent;
        if (leftChild.parent === undefined) {
            this.intervalTree.root = leftChild;
        }
        else {
            if (leftChild.parent.left === this) {
                leftChild.parent.left = leftChild;
            }
            else if (leftChild.parent.right === this) {
                leftChild.parent.right = leftChild;
            }
        }
        this.left = leftChild.right;
        if (this.left !== undefined) {
            this.left.parent = this;
        }
        leftChild.right = this;
        this.parent = leftChild;
        this.updateHeight();
        leftChild.updateHeight();
    };
    // Rebalances the tree if the height value between two nodes of the same parent is greater than
    // two. There are 4 cases that can happen which are outlined in the graphics above
    Node.prototype._rebalance = function () {
        if (height(this.left) >= 2 + height(this.right)) {
            var left = this.left;
            if (height(left.left) >= height(left.right)) {
                // Left-Left case
                this._rightRotate();
                this._updateMaxAfterRightRotate();
            }
            else {
                // Left-Right case
                left._leftRotate();
                this._rightRotate();
                this._updateMaxAfterRightRotate();
            }
        }
        else if (height(this.right) >= 2 + height(this.left)) {
            var right = this.right;
            if (height(right.right) >= height(right.left)) {
                // Right-Right case
                this._leftRotate();
                this._updateMaxAfterLeftRotate();
            }
            else {
                // Right-Left case
                right._rightRotate();
                this._leftRotate();
                this._updateMaxAfterLeftRotate();
            }
        }
    };
    Node.prototype.insert = function (record) {
        if (record.low < this.key) {
            // Insert into left subtree
            if (this.left === undefined) {
                this.left = new Node(this.intervalTree, record);
                this.left.parent = this;
            }
            else {
                this.left.insert(record);
            }
        }
        else {
            // Insert into right subtree
            if (this.right === undefined) {
                this.right = new Node(this.intervalTree, record);
                this.right.parent = this;
            }
            else {
                this.right.insert(record);
            }
        }
        // Update the max value of this ancestor if needed
        if (this.max < record.high) {
            this.max = record.high;
        }
        // Update height of each node
        this.updateHeight();
        // Rebalance the tree to ensure all operations are executed in O(logn) time. This is especially
        // important in searching, as the tree has a high chance of degenerating without the rebalancing
        this._rebalance();
    };
    Node.prototype._getOverlappingRecords = function (currentNode, low, high) {
        if (currentNode.key <= high && low <= currentNode.getNodeHigh()) {
            // Nodes are overlapping, check if individual records in the node are overlapping
            var tempResults = [];
            for (var i = 0; i < currentNode.records.length; i++) {
                if (currentNode.records[i].high >= low) {
                    tempResults.push(currentNode.records[i]);
                }
            }
            return tempResults;
        }
        return [];
    };
    Node.prototype.search = function (low, high) {
        // Don't search nodes that don't exist
        if (this === undefined) {
            return [];
        }
        var leftSearch = [];
        var ownSearch = [];
        var rightSearch = [];
        // If interval is to the right of the rightmost point of any interval in this node and all its
        // children, there won't be any matches
        if (low > this.max) {
            return [];
        }
        // Search left children
        if (this.left !== undefined && this.left.max >= low) {
            leftSearch = this.left.search(low, high);
        }
        // Check this node
        ownSearch = this._getOverlappingRecords(this, low, high);
        // If interval is to the left of the start of this interval, then it can't be in any child to
        // the right
        if (high < this.key) {
            return leftSearch.concat(ownSearch);
        }
        // Otherwise, search right children
        if (this.right !== undefined) {
            rightSearch = this.right.search(low, high);
        }
        // Return accumulated results, if any
        return leftSearch.concat(ownSearch, rightSearch);
    };
    // Searches for a node by a `key` value
    Node.prototype.searchExisting = function (low) {
        if (this === undefined) {
            return undefined;
        }
        if (this.key === low) {
            return this;
        }
        else if (low < this.key) {
            if (this.left !== undefined) {
                return this.left.searchExisting(low);
            }
        }
        else {
            if (this.right !== undefined) {
                return this.right.searchExisting(low);
            }
        }
        return undefined;
    };
    // Returns the smallest node of the subtree
    Node.prototype._minValue = function () {
        if (this.left === undefined) {
            return this;
        }
        else {
            return this.left._minValue();
        }
    };
    Node.prototype.remove = function (node) {
        var parent = this.parent;
        if (node.key < this.key) {
            // Node to be removed is on the left side
            if (this.left !== undefined) {
                return this.left.remove(node);
            }
            else {
                return undefined;
            }
        }
        else if (node.key > this.key) {
            // Node to be removed is on the right side
            if (this.right !== undefined) {
                return this.right.remove(node);
            }
            else {
                return undefined;
            }
        }
        else {
            if (this.left !== undefined && this.right !== undefined) {
                // Node has two children
                var minValue = this.right._minValue();
                this.key = minValue.key;
                this.records = minValue.records;
                return this.right.remove(this);
            }
            else if (parent.left === this) {
                // One child or no child case on left side
                if (this.right !== undefined) {
                    parent.left = this.right;
                    this.right.parent = parent;
                }
                else {
                    parent.left = this.left;
                    if (this.left !== undefined) {
                        this.left.parent = parent;
                    }
                }
                parent.updateMaxOfParents();
                parent.updateHeight();
                parent._rebalance();
                return this;
            }
            else if (parent.right === this) {
                // One child or no child case on right side
                if (this.right !== undefined) {
                    parent.right = this.right;
                    this.right.parent = parent;
                }
                else {
                    parent.right = this.left;
                    if (this.left !== undefined) {
                        this.left.parent = parent;
                    }
                }
                parent.updateMaxOfParents();
                parent.updateHeight();
                parent._rebalance();
                return this;
            }
        }
    };
    return Node;
}());
exports.Node = Node;
var IntervalTree = /** @class */ (function () {
    function IntervalTree() {
        this.count = 0;
    }
    IntervalTree.prototype.insert = function (record) {
        if (record.low > record.high) {
            throw new Error('`low` value must be lower or equal to `high` value');
        }
        if (this.root === undefined) {
            // Base case: Tree is empty, new node becomes root
            this.root = new Node(this, record);
            this.count++;
            return true;
        }
        else {
            // Otherwise, check if node already exists with the same key
            var node = this.root.searchExisting(record.low);
            if (node !== undefined) {
                // Check the records in this node if there already is the one with same low, high, data
                for (var i = 0; i < node.records.length; i++) {
                    if (isSame(node.records[i], record)) {
                        // This record is same as the one we're trying to insert; return false to indicate
                        // nothing has been inserted
                        return false;
                    }
                }
                // Add the record to the node
                node.records.push(record);
                // Update max of the node and its parents if necessary
                if (record.high > node.max) {
                    node.max = record.high;
                    if (node.parent) {
                        node.parent.updateMaxOfParents();
                    }
                }
                this.count++;
                return true;
            }
            else {
                // Node with this key doesn't already exist. Call insert function on root's node
                this.root.insert(record);
                this.count++;
                return true;
            }
        }
    };
    IntervalTree.prototype.search = function (low, high) {
        if (this.root === undefined) {
            // Tree is empty; return empty array
            return [];
        }
        else {
            return this.root.search(low, high);
        }
    };
    IntervalTree.prototype.remove = function (record) {
        if (this.root === undefined) {
            // Tree is empty; nothing to remove
            return false;
        }
        else {
            var node = this.root.searchExisting(record.low);
            if (node === undefined) {
                return false;
            }
            else if (node.records.length > 1) {
                var removedRecord = void 0;
                // Node with this key has 2 or more records. Find the one we need and remove it
                for (var i = 0; i < node.records.length; i++) {
                    if (isSame(node.records[i], record)) {
                        removedRecord = node.records[i];
                        node.records.splice(i, 1);
                        break;
                    }
                }
                if (removedRecord) {
                    removedRecord = undefined;
                    // Update max of that node and its parents if necessary
                    if (record.high === node.max) {
                        var nodeHigh = node.getNodeHigh();
                        if (node.left !== undefined && node.right !== undefined) {
                            node.max = Math.max(Math.max(node.left.max, node.right.max), nodeHigh);
                        }
                        else if (node.left !== undefined && node.right === undefined) {
                            node.max = Math.max(node.left.max, nodeHigh);
                        }
                        else if (node.left === undefined && node.right !== undefined) {
                            node.max = Math.max(node.right.max, nodeHigh);
                        }
                        else {
                            node.max = nodeHigh;
                        }
                        if (node.parent) {
                            node.parent.updateMaxOfParents();
                        }
                    }
                    this.count--;
                    return true;
                }
                else {
                    return false;
                }
            }
            else if (node.records.length === 1) {
                // Node with this key has only 1 record. Check if the remaining record in this node is
                // actually the one we want to remove
                if (isSame(node.records[0], record)) {
                    // The remaining record is the one we want to remove. Remove the whole node from the tree
                    if (this.root.key === node.key) {
                        // We're removing the root element. Create a dummy node that will temporarily take
                        // root's parent role
                        var rootParent = new Node(this, { low: record.low, high: record.low });
                        rootParent.left = this.root;
                        this.root.parent = rootParent;
                        var removedNode = this.root.remove(node);
                        this.root = rootParent.left;
                        if (this.root !== undefined) {
                            this.root.parent = undefined;
                        }
                        if (removedNode) {
                            removedNode = undefined;
                            this.count--;
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                    else {
                        var removedNode = this.root.remove(node);
                        if (removedNode) {
                            removedNode = undefined;
                            this.count--;
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                }
                else {
                    // The remaining record is not the one we want to remove
                    return false;
                }
            }
            else {
                // No records at all in this node?! Shouldn't happen
                return false;
            }
        }
    };
    IntervalTree.prototype.inOrder = function () {
        return new InOrder(this.root);
    };
    IntervalTree.prototype.preOrder = function () {
        return new PreOrder(this.root);
    };
    return IntervalTree;
}());
exports.IntervalTree = IntervalTree;
var DataIntervalTree = /** @class */ (function () {
    function DataIntervalTree() {
        this.tree = new IntervalTree();
    }
    DataIntervalTree.prototype.insert = function (low, high, data) {
        return this.tree.insert({ low: low, high: high, data: data });
    };
    DataIntervalTree.prototype.remove = function (low, high, data) {
        return this.tree.remove({ low: low, high: high, data: data });
    };
    DataIntervalTree.prototype.search = function (low, high) {
        return this.tree.search(low, high).map(function (v) { return v.data; });
    };
    DataIntervalTree.prototype.inOrder = function () {
        return this.tree.inOrder();
    };
    DataIntervalTree.prototype.preOrder = function () {
        return this.tree.preOrder();
    };
    Object.defineProperty(DataIntervalTree.prototype, "count", {
        get: function () {
            return this.tree.count;
        },
        enumerable: true,
        configurable: true
    });
    return DataIntervalTree;
}());
exports.default = DataIntervalTree;
var InOrder = /** @class */ (function () {
    function InOrder(startNode) {
        this.stack = [];
        if (startNode !== undefined) {
            this.push(startNode);
        }
    }
    InOrder.prototype.next = function () {
        // Will only happen if stack is empty and pop is called
        if (this.currentNode === undefined) {
            return {
                done: true,
                value: undefined,
            };
        }
        // Process this node
        if (this.i < this.currentNode.records.length) {
            return {
                done: false,
                value: this.currentNode.records[this.i++],
            };
        }
        if (this.currentNode.right !== undefined) {
            this.push(this.currentNode.right);
        }
        else {
            // Might pop the last and set this.currentNode = undefined
            this.pop();
        }
        return this.next();
    };
    InOrder.prototype.push = function (node) {
        this.currentNode = node;
        this.i = 0;
        while (this.currentNode.left !== undefined) {
            this.stack.push(this.currentNode);
            this.currentNode = this.currentNode.left;
        }
    };
    InOrder.prototype.pop = function () {
        this.currentNode = this.stack.pop();
        this.i = 0;
    };
    return InOrder;
}());
exports.InOrder = InOrder;
if (typeof Symbol === 'function') {
    InOrder.prototype[Symbol.iterator] = function () { return this; };
}
var PreOrder = /** @class */ (function () {
    function PreOrder(startNode) {
        this.stack = [];
        this.i = 0;
        this.currentNode = startNode;
    }
    PreOrder.prototype.next = function () {
        // Will only happen if stack is empty and pop is called,
        // which only happens if there is no right node (i.e we are done)
        if (this.currentNode === undefined) {
            return {
                done: true,
                value: undefined,
            };
        }
        // Process this node
        if (this.i < this.currentNode.records.length) {
            return {
                done: false,
                value: this.currentNode.records[this.i++],
            };
        }
        if (this.currentNode.right !== undefined) {
            this.push(this.currentNode.right);
        }
        if (this.currentNode.left !== undefined) {
            this.push(this.currentNode.left);
        }
        this.pop();
        return this.next();
    };
    PreOrder.prototype.push = function (node) {
        this.stack.push(node);
    };
    PreOrder.prototype.pop = function () {
        this.currentNode = this.stack.pop();
        this.i = 0;
    };
    return PreOrder;
}());
exports.PreOrder = PreOrder;
if (typeof Symbol === 'function') {
    PreOrder.prototype[Symbol.iterator] = function () { return this; };
}
//# sourceMappingURL=index.js.map

/***/ }),
/* 45 */
/***/ (function(module, exports) {

//

module.exports = function shallowEqual(objA, objB, compare, compareContext) {
  var ret = compare ? compare.call(compareContext, objA, objB) : void 0;

  if (ret !== void 0) {
    return !!ret;
  }

  if (objA === objB) {
    return true;
  }

  if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);

  // Test for A's keys different from B.
  for (var idx = 0; idx < keysA.length; idx++) {
    var key = keysA[idx];

    if (!bHasOwnProperty(key)) {
      return false;
    }

    var valueA = objA[key];
    var valueB = objB[key];

    ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;

    if (ret === false || (ret === void 0 && valueA !== valueB)) {
      return false;
    }
  }

  return true;
};


/***/ }),
/* 46 */
/***/ (function(module, exports) {

module.exports = require("fast-levenshtein");

/***/ }),
/* 47 */
/***/ (function(module, exports) {

exports = module.exports = SemVer;

// The debug function is excluded entirely from the minified version.
/* nomin */ var debug;
/* nomin */ if (typeof process === 'object' &&
    /* nomin */ process.env &&
    /* nomin */ process.env.NODE_DEBUG &&
    /* nomin */ /\bsemver\b/i.test(process.env.NODE_DEBUG))
  /* nomin */ debug = function() {
    /* nomin */ var args = Array.prototype.slice.call(arguments, 0);
    /* nomin */ args.unshift('SEMVER');
    /* nomin */ console.log.apply(console, args);
    /* nomin */ };
/* nomin */ else
  /* nomin */ debug = function() {};

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
exports.SEMVER_SPEC_VERSION = '2.0.0';

var MAX_LENGTH = 256;
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;

// Max safe segment length for coercion.
var MAX_SAFE_COMPONENT_LENGTH = 16;

// The actual regexps go on exports.re
var re = exports.re = [];
var src = exports.src = [];
var R = 0;

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

var NUMERICIDENTIFIER = R++;
src[NUMERICIDENTIFIER] = '0|[1-9]\\d*';
var NUMERICIDENTIFIERLOOSE = R++;
src[NUMERICIDENTIFIERLOOSE] = '[0-9]+';


// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

var NONNUMERICIDENTIFIER = R++;
src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';


// ## Main Version
// Three dot-separated numeric identifiers.

var MAINVERSION = R++;
src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')';

var MAINVERSIONLOOSE = R++;
src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')';

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

var PRERELEASEIDENTIFIER = R++;
src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +
                            '|' + src[NONNUMERICIDENTIFIER] + ')';

var PRERELEASEIDENTIFIERLOOSE = R++;
src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +
                                 '|' + src[NONNUMERICIDENTIFIER] + ')';


// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

var PRERELEASE = R++;
src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +
                  '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))';

var PRERELEASELOOSE = R++;
src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +
                       '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

var BUILDIDENTIFIER = R++;
src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

var BUILD = R++;
src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] +
             '(?:\\.' + src[BUILDIDENTIFIER] + ')*))';


// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

var FULL = R++;
var FULLPLAIN = 'v?' + src[MAINVERSION] +
                src[PRERELEASE] + '?' +
                src[BUILD] + '?';

src[FULL] = '^' + FULLPLAIN + '$';

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] +
                 src[PRERELEASELOOSE] + '?' +
                 src[BUILD] + '?';

var LOOSE = R++;
src[LOOSE] = '^' + LOOSEPLAIN + '$';

var GTLT = R++;
src[GTLT] = '((?:<|>)?=?)';

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
var XRANGEIDENTIFIERLOOSE = R++;
src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
var XRANGEIDENTIFIER = R++;
src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*';

var XRANGEPLAIN = R++;
src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:' + src[PRERELEASE] + ')?' +
                   src[BUILD] + '?' +
                   ')?)?';

var XRANGEPLAINLOOSE = R++;
src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:' + src[PRERELEASELOOSE] + ')?' +
                        src[BUILD] + '?' +
                        ')?)?';

var XRANGE = R++;
src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$';
var XRANGELOOSE = R++;
src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$';

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
var COERCE = R++;
src[COERCE] = '(?:^|[^\\d])' +
              '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:$|[^\\d])';

// Tilde ranges.
// Meaning is "reasonably at or greater than"
var LONETILDE = R++;
src[LONETILDE] = '(?:~>?)';

var TILDETRIM = R++;
src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+';
re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');
var tildeTrimReplace = '$1~';

var TILDE = R++;
src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';
var TILDELOOSE = R++;
src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';

// Caret ranges.
// Meaning is "at least and backwards compatible with"
var LONECARET = R++;
src[LONECARET] = '(?:\\^)';

var CARETTRIM = R++;
src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+';
re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');
var caretTrimReplace = '$1^';

var CARET = R++;
src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';
var CARETLOOSE = R++;
src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';

// A simple gt/lt/eq thing, or just "" to indicate "any version"
var COMPARATORLOOSE = R++;
src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$';
var COMPARATOR = R++;
src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$';


// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
var COMPARATORTRIM = R++;
src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] +
                      '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';

// this one has to use the /g flag
re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');
var comparatorTrimReplace = '$1$2$3';


// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
var HYPHENRANGE = R++;
src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' +
                   '\\s+-\\s+' +
                   '(' + src[XRANGEPLAIN] + ')' +
                   '\\s*$';

var HYPHENRANGELOOSE = R++;
src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s+-\\s+' +
                        '(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s*$';

// Star ranges basically just allow anything at all.
var STAR = R++;
src[STAR] = '(<|>)?=?\\s*\\*';

// Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.
for (var i = 0; i < R; i++) {
  debug(i, src[i]);
  if (!re[i])
    re[i] = new RegExp(src[i]);
}

exports.parse = parse;
function parse(version, options) {
  if (!options || typeof options !== 'object')
    options = { loose: !!options, includePrerelease: false }

  if (version instanceof SemVer)
    return version;

  if (typeof version !== 'string')
    return null;

  if (version.length > MAX_LENGTH)
    return null;

  var r = options.loose ? re[LOOSE] : re[FULL];
  if (!r.test(version))
    return null;

  try {
    return new SemVer(version, options);
  } catch (er) {
    return null;
  }
}

exports.valid = valid;
function valid(version, options) {
  var v = parse(version, options);
  return v ? v.version : null;
}


exports.clean = clean;
function clean(version, options) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), options);
  return s ? s.version : null;
}

exports.SemVer = SemVer;

function SemVer(version, options) {
  if (!options || typeof options !== 'object')
    options = { loose: !!options, includePrerelease: false }
  if (version instanceof SemVer) {
    if (version.loose === options.loose)
      return version;
    else
      version = version.version;
  } else if (typeof version !== 'string') {
    throw new TypeError('Invalid Version: ' + version);
  }

  if (version.length > MAX_LENGTH)
    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')

  if (!(this instanceof SemVer))
    return new SemVer(version, options);

  debug('SemVer', version, options);
  this.options = options;
  this.loose = !!options.loose;

  var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL]);

  if (!m)
    throw new TypeError('Invalid Version: ' + version);

  this.raw = version;

  // these are actually numbers
  this.major = +m[1];
  this.minor = +m[2];
  this.patch = +m[3];

  if (this.major > MAX_SAFE_INTEGER || this.major < 0)
    throw new TypeError('Invalid major version')

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)
    throw new TypeError('Invalid minor version')

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)
    throw new TypeError('Invalid patch version')

  // numberify any prerelease numeric ids
  if (!m[4])
    this.prerelease = [];
  else
    this.prerelease = m[4].split('.').map(function(id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id;
        if (num >= 0 && num < MAX_SAFE_INTEGER)
          return num;
      }
      return id;
    });

  this.build = m[5] ? m[5].split('.') : [];
  this.format();
}

SemVer.prototype.format = function() {
  this.version = this.major + '.' + this.minor + '.' + this.patch;
  if (this.prerelease.length)
    this.version += '-' + this.prerelease.join('.');
  return this.version;
};

SemVer.prototype.toString = function() {
  return this.version;
};

SemVer.prototype.compare = function(other) {
  debug('SemVer.compare', this.version, this.options, other);
  if (!(other instanceof SemVer))
    other = new SemVer(other, this.options);

  return this.compareMain(other) || this.comparePre(other);
};

SemVer.prototype.compareMain = function(other) {
  if (!(other instanceof SemVer))
    other = new SemVer(other, this.options);

  return compareIdentifiers(this.major, other.major) ||
         compareIdentifiers(this.minor, other.minor) ||
         compareIdentifiers(this.patch, other.patch);
};

SemVer.prototype.comparePre = function(other) {
  if (!(other instanceof SemVer))
    other = new SemVer(other, this.options);

  // NOT having a prerelease is > having one
  if (this.prerelease.length && !other.prerelease.length)
    return -1;
  else if (!this.prerelease.length && other.prerelease.length)
    return 1;
  else if (!this.prerelease.length && !other.prerelease.length)
    return 0;

  var i = 0;
  do {
    var a = this.prerelease[i];
    var b = other.prerelease[i];
    debug('prerelease compare', i, a, b);
    if (a === undefined && b === undefined)
      return 0;
    else if (b === undefined)
      return 1;
    else if (a === undefined)
      return -1;
    else if (a === b)
      continue;
    else
      return compareIdentifiers(a, b);
  } while (++i);
};

// preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.
SemVer.prototype.inc = function(release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0;
      this.patch = 0;
      this.minor = 0;
      this.major++;
      this.inc('pre', identifier);
      break;
    case 'preminor':
      this.prerelease.length = 0;
      this.patch = 0;
      this.minor++;
      this.inc('pre', identifier);
      break;
    case 'prepatch':
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0;
      this.inc('patch', identifier);
      this.inc('pre', identifier);
      break;
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.
    case 'prerelease':
      if (this.prerelease.length === 0)
        this.inc('patch', identifier);
      this.inc('pre', identifier);
      break;

    case 'major':
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0)
        this.major++;
      this.minor = 0;
      this.patch = 0;
      this.prerelease = [];
      break;
    case 'minor':
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0)
        this.minor++;
      this.patch = 0;
      this.prerelease = [];
      break;
    case 'patch':
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0)
        this.patch++;
      this.prerelease = [];
      break;
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
    case 'pre':
      if (this.prerelease.length === 0)
        this.prerelease = [0];
      else {
        var i = this.prerelease.length;
        while (--i >= 0) {
          if (typeof this.prerelease[i] === 'number') {
            this.prerelease[i]++;
            i = -2;
          }
        }
        if (i === -1) // didn't increment anything
          this.prerelease.push(0);
      }
      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1]))
            this.prerelease = [identifier, 0];
        } else
          this.prerelease = [identifier, 0];
      }
      break;

    default:
      throw new Error('invalid increment argument: ' + release);
  }
  this.format();
  this.raw = this.version;
  return this;
};

exports.inc = inc;
function inc(version, release, loose, identifier) {
  if (typeof(loose) === 'string') {
    identifier = loose;
    loose = undefined;
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version;
  } catch (er) {
    return null;
  }
}

exports.diff = diff;
function diff(version1, version2) {
  if (eq(version1, version2)) {
    return null;
  } else {
    var v1 = parse(version1);
    var v2 = parse(version2);
    if (v1.prerelease.length || v2.prerelease.length) {
      for (var key in v1) {
        if (key === 'major' || key === 'minor' || key === 'patch') {
          if (v1[key] !== v2[key]) {
            return 'pre'+key;
          }
        }
      }
      return 'prerelease';
    }
    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return key;
        }
      }
    }
  }
}

exports.compareIdentifiers = compareIdentifiers;

var numeric = /^[0-9]+$/;
function compareIdentifiers(a, b) {
  var anum = numeric.test(a);
  var bnum = numeric.test(b);

  if (anum && bnum) {
    a = +a;
    b = +b;
  }

  return (anum && !bnum) ? -1 :
         (bnum && !anum) ? 1 :
         a < b ? -1 :
         a > b ? 1 :
         0;
}

exports.rcompareIdentifiers = rcompareIdentifiers;
function rcompareIdentifiers(a, b) {
  return compareIdentifiers(b, a);
}

exports.major = major;
function major(a, loose) {
  return new SemVer(a, loose).major;
}

exports.minor = minor;
function minor(a, loose) {
  return new SemVer(a, loose).minor;
}

exports.patch = patch;
function patch(a, loose) {
  return new SemVer(a, loose).patch;
}

exports.compare = compare;
function compare(a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose));
}

exports.compareLoose = compareLoose;
function compareLoose(a, b) {
  return compare(a, b, true);
}

exports.rcompare = rcompare;
function rcompare(a, b, loose) {
  return compare(b, a, loose);
}

exports.sort = sort;
function sort(list, loose) {
  return list.sort(function(a, b) {
    return exports.compare(a, b, loose);
  });
}

exports.rsort = rsort;
function rsort(list, loose) {
  return list.sort(function(a, b) {
    return exports.rcompare(a, b, loose);
  });
}

exports.gt = gt;
function gt(a, b, loose) {
  return compare(a, b, loose) > 0;
}

exports.lt = lt;
function lt(a, b, loose) {
  return compare(a, b, loose) < 0;
}

exports.eq = eq;
function eq(a, b, loose) {
  return compare(a, b, loose) === 0;
}

exports.neq = neq;
function neq(a, b, loose) {
  return compare(a, b, loose) !== 0;
}

exports.gte = gte;
function gte(a, b, loose) {
  return compare(a, b, loose) >= 0;
}

exports.lte = lte;
function lte(a, b, loose) {
  return compare(a, b, loose) <= 0;
}

exports.cmp = cmp;
function cmp(a, op, b, loose) {
  var ret;
  switch (op) {
    case '===':
      if (typeof a === 'object') a = a.version;
      if (typeof b === 'object') b = b.version;
      ret = a === b;
      break;
    case '!==':
      if (typeof a === 'object') a = a.version;
      if (typeof b === 'object') b = b.version;
      ret = a !== b;
      break;
    case '': case '=': case '==': ret = eq(a, b, loose); break;
    case '!=': ret = neq(a, b, loose); break;
    case '>': ret = gt(a, b, loose); break;
    case '>=': ret = gte(a, b, loose); break;
    case '<': ret = lt(a, b, loose); break;
    case '<=': ret = lte(a, b, loose); break;
    default: throw new TypeError('Invalid operator: ' + op);
  }
  return ret;
}

exports.Comparator = Comparator;
function Comparator(comp, options) {
  if (!options || typeof options !== 'object')
    options = { loose: !!options, includePrerelease: false }

  if (comp instanceof Comparator) {
    if (comp.loose === !!options.loose)
      return comp;
    else
      comp = comp.value;
  }

  if (!(this instanceof Comparator))
    return new Comparator(comp, options);

  debug('comparator', comp, options);
  this.options = options;
  this.loose = !!options.loose;
  this.parse(comp);

  if (this.semver === ANY)
    this.value = '';
  else
    this.value = this.operator + this.semver.version;

  debug('comp', this);
}

var ANY = {};
Comparator.prototype.parse = function(comp) {
  var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
  var m = comp.match(r);

  if (!m)
    throw new TypeError('Invalid comparator: ' + comp);

  this.operator = m[1];
  if (this.operator === '=')
    this.operator = '';

  // if it literally is just '>' or '' then allow anything.
  if (!m[2])
    this.semver = ANY;
  else
    this.semver = new SemVer(m[2], this.options.loose);
};

Comparator.prototype.toString = function() {
  return this.value;
};

Comparator.prototype.test = function(version) {
  debug('Comparator.test', version, this.options.loose);

  if (this.semver === ANY)
    return true;

  if (typeof version === 'string')
    version = new SemVer(version, this.options);

  return cmp(version, this.operator, this.semver, this.options);
};

Comparator.prototype.intersects = function(comp, options) {
  if (!(comp instanceof Comparator)) {
    throw new TypeError('a Comparator is required');
  }

  if (!options || typeof options !== 'object')
    options = { loose: !!options, includePrerelease: false }

  var rangeTmp;

  if (this.operator === '') {
    rangeTmp = new Range(comp.value, options);
    return satisfies(this.value, rangeTmp, options);
  } else if (comp.operator === '') {
    rangeTmp = new Range(this.value, options);
    return satisfies(comp.semver, rangeTmp, options);
  }

  var sameDirectionIncreasing =
    (this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '>=' || comp.operator === '>');
  var sameDirectionDecreasing =
    (this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '<=' || comp.operator === '<');
  var sameSemVer = this.semver.version === comp.semver.version;
  var differentDirectionsInclusive =
    (this.operator === '>=' || this.operator === '<=') &&
    (comp.operator === '>=' || comp.operator === '<=');
  var oppositeDirectionsLessThan =
    cmp(this.semver, '<', comp.semver, options) &&
    ((this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '<=' || comp.operator === '<'));
  var oppositeDirectionsGreaterThan =
    cmp(this.semver, '>', comp.semver, options) &&
    ((this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '>=' || comp.operator === '>'));

  return sameDirectionIncreasing || sameDirectionDecreasing ||
    (sameSemVer && differentDirectionsInclusive) ||
    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
};


exports.Range = Range;
function Range(range, options) {
  if (!options || typeof options !== 'object')
    options = { loose: !!options, includePrerelease: false }

  if (range instanceof Range) {
    if (range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease) {
      return range;
    } else {
      return new Range(range.raw, options);
    }
  }

  if (range instanceof Comparator) {
    return new Range(range.value, options);
  }

  if (!(this instanceof Range))
    return new Range(range, options);

  this.options = options;
  this.loose = !!options.loose;
  this.includePrerelease = !!options.includePrerelease

  // First, split based on boolean or ||
  this.raw = range;
  this.set = range.split(/\s*\|\|\s*/).map(function(range) {
    return this.parseRange(range.trim());
  }, this).filter(function(c) {
    // throw out any that are not relevant for whatever reason
    return c.length;
  });

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + range);
  }

  this.format();
}

Range.prototype.format = function() {
  this.range = this.set.map(function(comps) {
    return comps.join(' ').trim();
  }).join('||').trim();
  return this.range;
};

Range.prototype.toString = function() {
  return this.range;
};

Range.prototype.parseRange = function(range) {
  var loose = this.options.loose;
  range = range.trim();
  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
  range = range.replace(hr, hyphenReplace);
  debug('hyphen replace', range);
  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
  debug('comparator trim', range, re[COMPARATORTRIM]);

  // `~ 1.2.3` => `~1.2.3`
  range = range.replace(re[TILDETRIM], tildeTrimReplace);

  // `^ 1.2.3` => `^1.2.3`
  range = range.replace(re[CARETTRIM], caretTrimReplace);

  // normalize spaces
  range = range.split(/\s+/).join(' ');

  // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
  var set = range.split(' ').map(function(comp) {
    return parseComparator(comp, this.options);
  }, this).join(' ').split(/\s+/);
  if (this.options.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function(comp) {
      return !!comp.match(compRe);
    });
  }
  set = set.map(function(comp) {
    return new Comparator(comp, this.options);
  }, this);

  return set;
};

Range.prototype.intersects = function(range, options) {
  if (!(range instanceof Range)) {
    throw new TypeError('a Range is required');
  }

  return this.set.some(function(thisComparators) {
    return thisComparators.every(function(thisComparator) {
      return range.set.some(function(rangeComparators) {
        return rangeComparators.every(function(rangeComparator) {
          return thisComparator.intersects(rangeComparator, options);
        });
      });
    });
  });
};

// Mostly just for testing and legacy API reasons
exports.toComparators = toComparators;
function toComparators(range, options) {
  return new Range(range, options).set.map(function(comp) {
    return comp.map(function(c) {
      return c.value;
    }).join(' ').trim().split(' ');
  });
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
function parseComparator(comp, options) {
  debug('comp', comp, options);
  comp = replaceCarets(comp, options);
  debug('caret', comp);
  comp = replaceTildes(comp, options);
  debug('tildes', comp);
  comp = replaceXRanges(comp, options);
  debug('xrange', comp);
  comp = replaceStars(comp, options);
  debug('stars', comp);
  return comp;
}

function isX(id) {
  return !id || id.toLowerCase() === 'x' || id === '*';
}

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
function replaceTildes(comp, options) {
  return comp.trim().split(/\s+/).map(function(comp) {
    return replaceTilde(comp, options);
  }).join(' ');
}

function replaceTilde(comp, options) {
  if (!options || typeof options !== 'object')
    options = { loose: !!options, includePrerelease: false }
  var r = options.loose ? re[TILDELOOSE] : re[TILDE];
  return comp.replace(r, function(_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr);
    var ret;

    if (isX(M))
      ret = '';
    else if (isX(m))
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    else if (isX(p))
      // ~1.2 == >=1.2.0 <1.3.0
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
    else if (pr) {
      debug('replaceTilde pr', pr);
      if (pr.charAt(0) !== '-')
        pr = '-' + pr;
      ret = '>=' + M + '.' + m + '.' + p + pr +
            ' <' + M + '.' + (+m + 1) + '.0';
    } else
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p +
            ' <' + M + '.' + (+m + 1) + '.0';

    debug('tilde return', ret);
    return ret;
  });
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0
function replaceCarets(comp, options) {
  return comp.trim().split(/\s+/).map(function(comp) {
    return replaceCaret(comp, options);
  }).join(' ');
}

function replaceCaret(comp, options) {
  debug('caret', comp, options);
  if (!options || typeof options !== 'object')
    options = { loose: !!options, includePrerelease: false }
  var r = options.loose ? re[CARETLOOSE] : re[CARET];
  return comp.replace(r, function(_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr);
    var ret;

    if (isX(M))
      ret = '';
    else if (isX(m))
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    else if (isX(p)) {
      if (M === '0')
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
      else
        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
    } else if (pr) {
      debug('replaceCaret pr', pr);
      if (pr.charAt(0) !== '-')
        pr = '-' + pr;
      if (M === '0') {
        if (m === '0')
          ret = '>=' + M + '.' + m + '.' + p + pr +
                ' <' + M + '.' + m + '.' + (+p + 1);
        else
          ret = '>=' + M + '.' + m + '.' + p + pr +
                ' <' + M + '.' + (+m + 1) + '.0';
      } else
        ret = '>=' + M + '.' + m + '.' + p + pr +
              ' <' + (+M + 1) + '.0.0';
    } else {
      debug('no pr');
      if (M === '0') {
        if (m === '0')
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + m + '.' + (+p + 1);
        else
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + (+m + 1) + '.0';
      } else
        ret = '>=' + M + '.' + m + '.' + p +
              ' <' + (+M + 1) + '.0.0';
    }

    debug('caret return', ret);
    return ret;
  });
}

function replaceXRanges(comp, options) {
  debug('replaceXRanges', comp, options);
  return comp.split(/\s+/).map(function(comp) {
    return replaceXRange(comp, options);
  }).join(' ');
}

function replaceXRange(comp, options) {
  comp = comp.trim();
  if (!options || typeof options !== 'object')
    options = { loose: !!options, includePrerelease: false }
  var r = options.loose ? re[XRANGELOOSE] : re[XRANGE];
  return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr);
    var xM = isX(M);
    var xm = xM || isX(m);
    var xp = xm || isX(p);
    var anyX = xp;

    if (gtlt === '=' && anyX)
      gtlt = '';

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0';
      } else {
        // nothing is forbidden
        ret = '*';
      }
    } else if (gtlt && anyX) {
      // replace X with 0
      if (xm)
        m = 0;
      if (xp)
        p = 0;

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>=';
        if (xm) {
          M = +M + 1;
          m = 0;
          p = 0;
        } else if (xp) {
          m = +m + 1;
          p = 0;
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<';
        if (xm)
          M = +M + 1;
        else
          m = +m + 1;
      }

      ret = gtlt + M + '.' + m + '.' + p;
    } else if (xm) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
    }

    debug('xRange return', ret);

    return ret;
  });
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
function replaceStars(comp, options) {
  debug('replaceStars', comp, options);
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[STAR], '');
}

// This function is passed to string.replace(re[HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0
function hyphenReplace($0,
                       from, fM, fm, fp, fpr, fb,
                       to, tM, tm, tp, tpr, tb) {

  if (isX(fM))
    from = '';
  else if (isX(fm))
    from = '>=' + fM + '.0.0';
  else if (isX(fp))
    from = '>=' + fM + '.' + fm + '.0';
  else
    from = '>=' + from;

  if (isX(tM))
    to = '';
  else if (isX(tm))
    to = '<' + (+tM + 1) + '.0.0';
  else if (isX(tp))
    to = '<' + tM + '.' + (+tm + 1) + '.0';
  else if (tpr)
    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;
  else
    to = '<=' + to;

  return (from + ' ' + to).trim();
}


// if ANY of the sets match ALL of its comparators, then pass
Range.prototype.test = function(version) {
  if (!version)
    return false;

  if (typeof version === 'string')
    version = new SemVer(version, this.options);

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version, this.options))
      return true;
  }
  return false;
};

function testSet(set, version, options) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version))
      return false;
  }

  if (!options)
    options = {}

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (var i = 0; i < set.length; i++) {
      debug(set[i].semver);
      if (set[i].semver === ANY)
        continue;

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver;
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch)
          return true;
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false;
  }

  return true;
}

exports.satisfies = satisfies;
function satisfies(version, range, options) {
  try {
    range = new Range(range, options);
  } catch (er) {
    return false;
  }
  return range.test(version);
}

exports.maxSatisfying = maxSatisfying;
function maxSatisfying(versions, range, options) {
  var max = null;
  var maxSV = null;
  try {
    var rangeObj = new Range(range, options);
  } catch (er) {
    return null;
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) { // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) { // compare(max, v, true)
        max = v;
        maxSV = new SemVer(max, options);
      }
    }
  })
  return max;
}

exports.minSatisfying = minSatisfying;
function minSatisfying(versions, range, options) {
  var min = null;
  var minSV = null;
  try {
    var rangeObj = new Range(range, options);
  } catch (er) {
    return null;
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) { // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) { // compare(min, v, true)
        min = v;
        minSV = new SemVer(min, options);
      }
    }
  })
  return min;
}

exports.validRange = validRange;
function validRange(range, options) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*';
  } catch (er) {
    return null;
  }
}

// Determine if version is less than all the versions possible in the range
exports.ltr = ltr;
function ltr(version, range, options) {
  return outside(version, range, '<', options);
}

// Determine if version is greater than all the versions possible in the range.
exports.gtr = gtr;
function gtr(version, range, options) {
  return outside(version, range, '>', options);
}

exports.outside = outside;
function outside(version, range, hilo, options) {
  version = new SemVer(version, options);
  range = new Range(range, options);

  var gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case '>':
      gtfn = gt;
      ltefn = lte;
      ltfn = lt;
      comp = '>';
      ecomp = '>=';
      break;
    case '<':
      gtfn = lt;
      ltefn = gte;
      ltfn = gt;
      comp = '<';
      ecomp = '<=';
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }

  // If it satisifes the range it is not outside
  if (satisfies(version, range, options)) {
    return false;
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i];

    var high = null;
    var low = null;

    comparators.forEach(function(comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator;
      low = low || comparator;
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator;
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator;
      }
    });

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false;
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false;
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false;
    }
  }
  return true;
}

exports.prerelease = prerelease;
function prerelease(version, options) {
  var parsed = parse(version, options);
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null;
}

exports.intersects = intersects;
function intersects(r1, r2, options) {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2)
}

exports.coerce = coerce;
function coerce(version) {
  if (version instanceof SemVer)
    return version;

  if (typeof version !== 'string')
    return null;

  var match = version.match(re[COERCE]);

  if (match == null)
    return null;

  return parse((match[1] || '0') + '.' + (match[2] || '0') + '.' + (match[3] || '0')); 
}


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(4);

var _helpers = __webpack_require__(1);

var _sagas = __webpack_require__(49);

var ast = _interopRequireWildcard(_sagas);

var _sagas2 = __webpack_require__(51);

var controller = _interopRequireWildcard(_sagas2);

var _sagas3 = __webpack_require__(31);

var solidity = _interopRequireWildcard(_sagas3);

var _sagas4 = __webpack_require__(29);

var evm = _interopRequireWildcard(_sagas4);

var _sagas5 = __webpack_require__(12);

var trace = _interopRequireWildcard(_sagas5);

var _sagas6 = __webpack_require__(17);

var data = _interopRequireWildcard(_sagas6);

var _sagas7 = __webpack_require__(52);

var ethers = _interopRequireWildcard(_sagas7);

var _actions = __webpack_require__(14);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:session:sagas");

function* saga() {
  debug("starting listeners");
  yield* forkListeners();

  // receiving & saving contracts into state
  debug("waiting for contract information");
  let { contexts, sources } = yield (0, _effects.take)(actions.RECORD_CONTRACTS);

  debug("recording contract binaries");
  yield* recordContexts(...contexts);

  debug("recording contract sources");
  yield* recordSources(...sources);

  debug("waiting for start");
  // wait for start signal
  let { txHash, provider } = yield (0, _effects.take)(actions.START);
  debug("starting");

  // process transaction
  debug("fetching transaction info");
  let err = yield* fetchTx(txHash, provider);
  if (err) {
    debug("error %o", err);
    yield* error(err);
  } else {
    debug("visiting ASTs");
    // visit asts
    yield* ast.visitAll();

    //save allocation table
    debug("saving allocation table");
    yield* data.recordAllocations();

    debug("readying");
    // signal that stepping can begin
    yield* ready();
  }
}

exports.default = (0, _helpers.prefixName)("session", saga);


function* forkListeners() {
  return yield (0, _effects.all)([controller, data, evm, solidity, trace, ethers].map(app => (0, _effects.fork)(app.saga)
  //ast no longer has a listener
  ));
}

function* fetchTx(txHash, provider) {
  let result = yield* ethers.inspectTransaction(txHash, provider);

  if (result.error) {
    return result.error;
  }

  yield* evm.begin(result);

  let addresses = yield* trace.processTrace(result.trace);
  if (result.address && addresses.indexOf(result.address) == -1) {
    addresses.push(result.address);
  }

  let binaries = yield* ethers.obtainBinaries(addresses);

  yield (0, _effects.all)(addresses.map((address, i) => (0, _effects.call)(recordInstance, address, binaries[i])));
}

function* recordContexts(...contexts) {
  for (let _ref of contexts) {
    let { contractName, binary, sourceMap, compiler } = _ref;

    yield* evm.addContext(contractName, { binary }, compiler);

    if (sourceMap) {
      yield* solidity.addSourceMap(binary, sourceMap);
    }
  }
}

function* recordSources(...sources) {
  for (let i = 0; i < sources.length; i++) {
    const sourceData = sources[i];
    if (sourceData !== undefined && sourceData !== null) {
      yield* solidity.addSource(sourceData.source, sourceData.sourcePath, sourceData.ast);
    }
  }
}

function* recordInstance(address, binary) {
  yield* evm.addInstance(address, binary);
}

function* ready() {
  yield (0, _effects.put)(actions.ready());
}

function* error(err) {
  yield (0, _effects.put)(actions.error(err));
}

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = __webpack_require__(5);

var _entries2 = _interopRequireDefault(_entries);

exports.visitAll = visitAll;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(4);

var _sagas = __webpack_require__(17);

var data = _interopRequireWildcard(_sagas);

var _selectors = __webpack_require__(15);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:ast:sagas");

function* walk(sourceId, node, pointer = "", parentId = null) {
  debug("walking %o %o", pointer, node);

  yield* handleEnter(sourceId, node, pointer, parentId);

  if (node instanceof Array) {
    for (let [i, child] of node.entries()) {
      yield (0, _effects.call)(walk, sourceId, child, `${pointer}/${i}`, parentId);
    }
  } else if (node instanceof Object) {
    for (let [key, child] of (0, _entries2.default)(node)) {
      yield (0, _effects.call)(walk, sourceId, child, `${pointer}/${key}`, node.id);
    }
  }

  yield* handleExit(sourceId, node, pointer);
}

function* handleEnter(sourceId, node, pointer, parentId) {
  if (!(node instanceof Object)) {
    return;
  }

  debug("entering %s", pointer);

  if (node.id !== undefined) {
    debug("%s recording scope %s", pointer, node.id);
    yield* data.scope(node.id, pointer, parentId, sourceId);
  }

  switch (node.nodeType) {
    case "VariableDeclaration":
      debug("%s recording variable %o", pointer, node);
      yield* data.declare(node);
      break;
    case "ContractDefinition":
    case "StructDefinition":
    case "EnumDefinition":
      yield* data.defineType(node);
      break;
  }
}

function* handleExit(sourceId, node, pointer) {
  debug("exiting %s", pointer);

  // no-op right now
}

function* visitAll() {
  let sources = yield (0, _effects.select)(_selectors2.default.views.sources);

  yield (0, _effects.all)((0, _entries2.default)(sources).filter(([_, source]) => source.ast).map(([id, { ast }]) => (0, _effects.call)(walk, id, ast)));

  debug("done visiting");
}

/***/ }),
/* 50 */
/***/ (function(module, exports) {

module.exports = require("bn.js");

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = __webpack_require__(23);

var _keys2 = _interopRequireDefault(_keys);

var _set = __webpack_require__(18);

var _set2 = _interopRequireDefault(_set);

exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(4);

var _helpers = __webpack_require__(1);

var _sagas = __webpack_require__(12);

var trace = _interopRequireWildcard(_sagas);

var _sagas2 = __webpack_require__(17);

var data = _interopRequireWildcard(_sagas2);

var _sagas3 = __webpack_require__(29);

var evm = _interopRequireWildcard(_sagas3);

var _sagas4 = __webpack_require__(31);

var solidity = _interopRequireWildcard(_sagas4);

var _actions = __webpack_require__(20);

var actions = _interopRequireWildcard(_actions);

var _selectors = __webpack_require__(25);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:controller:sagas");

//NOTE: when updating this don't forget to update CONTROL_ACTIONS in
//reducers.js as well!
const CONTROL_SAGAS = {
  [actions.ADVANCE]: advance,
  [actions.STEP_NEXT]: stepNext,
  [actions.STEP_OVER]: stepOver,
  [actions.STEP_INTO]: stepInto,
  [actions.STEP_OUT]: stepOut,
  [actions.CONTINUE]: continueUntilBreakpoint,
  [actions.RESET]: reset
};

/** AST node types that are skipped to filter out some noise */
const SKIPPED_TYPES = new _set2.default(["ContractDefinition", "VariableDeclaration"]);

function* saga() {
  while (true) {
    debug("waiting for control action");
    let action = yield (0, _effects.take)((0, _keys2.default)(CONTROL_SAGAS));
    debug("got control action");
    let saga = CONTROL_SAGAS[action.type];

    yield (0, _effects.race)({
      exec: (0, _effects.call)(saga, action), //not all will use this
      interrupt: (0, _effects.take)(actions.INTERRUPT)
    });
    yield (0, _effects.put)(actions.doneStepping());
  }
}

exports.default = (0, _helpers.prefixName)("controller", saga);

/*
 * Advance the state by the given number of instructions (but not past the end)
 */

function* advance(action = actions.advance()) {
  let { count } = action;
  for (let i = 0; i < count && !(yield (0, _effects.select)(_selectors2.default.finished)); i++) {
    yield* trace.advance();
  }
}

/**
 * stepNext - step to the next logical code segment
 *
 * Note: It might take multiple instructions to express the same section of code.
 * "Stepping", then, is stepping to the next logical item, not stepping to the next
 * instruction. See advance() if you'd like to advance by one instruction.
 */
function* stepNext() {
  const startingRange = yield (0, _effects.select)(_selectors2.default.current.location.sourceRange);

  var upcoming, finished;

  do {
    // advance at least once step
    yield* advance();

    // and check the next source range
    try {
      upcoming = yield (0, _effects.select)(_selectors2.default.current.location);
    } catch (e) {
      upcoming = null;
    }

    finished = yield (0, _effects.select)(_selectors2.default.finished);

    // if the next step's source range is still the same, keep going
  } while (!finished && (!upcoming || !upcoming.node || SKIPPED_TYPES.has(upcoming.node.nodeType) || upcoming.sourceRange.start == startingRange.start && upcoming.sourceRange.length == startingRange.length));
}

/**
 * stepInto - step into the current function
 *
 * Conceptually this is easy, but from a programming standpoint it's hard.
 * Code like `getBalance(msg.sender)` might be highlighted, but there could
 * be a number of different intermediate steps (like evaluating `msg.sender`)
 * before `getBalance` is stepped into. This function will step into the first
 * function available (where instruction.jump == "i"), ignoring any intermediate
 * steps that fall within the same code range. If there's a step encountered
 * that exists outside of the range, then stepInto will only execute until that
 * step.
 */
function* stepInto() {
  if (yield (0, _effects.select)(_selectors2.default.current.willJump)) {
    yield* stepNext();
    return;
  }

  if (yield (0, _effects.select)(_selectors2.default.current.location.isMultiline)) {
    yield* stepOver();
    return;
  }

  const startingDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
  const startingRange = yield (0, _effects.select)(_selectors2.default.current.location.sourceRange);
  var currentDepth;
  var currentRange;

  do {
    yield* stepNext();

    currentDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
    currentRange = yield (0, _effects.select)(_selectors2.default.current.location.sourceRange);
  } while (
  // the function stack has not increased,
  currentDepth <= startingDepth &&
  // the current source range begins on or after the starting range
  currentRange.start >= startingRange.start &&
  // and the current range ends on or before the starting range ends
  currentRange.start + currentRange.length <= startingRange.start + startingRange.length);
}

/**
 * Step out of the current function
 *
 * This will run until the debugger encounters a decrease in function depth.
 */
function* stepOut() {
  if (yield (0, _effects.select)(_selectors2.default.current.location.isMultiline)) {
    yield* stepOver();
    return;
  }

  const startingDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
  var currentDepth;

  do {
    yield* stepNext();

    currentDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
  } while (currentDepth >= startingDepth);
}

/**
 * stepOver - step over the current line
 *
 * Step over the current line. This will step to the next instruction that
 * exists on a different line of code within the same function depth.
 */
function* stepOver() {
  const startingDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
  const startingRange = yield (0, _effects.select)(_selectors2.default.current.location.sourceRange);
  var currentDepth;
  var currentRange;

  do {
    yield* stepNext();

    currentDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
    currentRange = yield (0, _effects.select)(_selectors2.default.current.location.sourceRange);
  } while (
  // keep stepping provided:
  //
  // we haven't jumped out
  !(currentDepth < startingDepth) && (
  // either: function depth is greater than starting (ignore function calls)
  // or, if we're at the same depth, keep stepping until we're on a new
  // line.
  currentDepth > startingDepth || currentRange.lines.start.line == startingRange.lines.start.line));
}

/**
 * continueUntilBreakpoint - step through execution until a breakpoint
 */
function* continueUntilBreakpoint() {
  var currentLocation, currentNode, currentLine, currentSourceId;
  var finished;
  var previousLine, previousSourceId;

  let breakpoints = yield (0, _effects.select)(_selectors2.default.breakpoints);

  let breakpointHit = false;

  currentLocation = yield (0, _effects.select)(_selectors2.default.current.location);
  currentNode = currentLocation.node.id;
  currentLine = currentLocation.sourceRange.lines.start.line;
  currentSourceId = currentLocation.source.id;

  do {
    yield* stepNext();

    previousLine = currentLine;
    previousSourceId = currentSourceId;

    currentLocation = yield (0, _effects.select)(_selectors2.default.current.location);
    finished = yield (0, _effects.select)(_selectors2.default.finished);
    debug("finished %o", finished);

    currentNode = currentLocation.node.id;
    currentLine = currentLocation.sourceRange.lines.start.line;
    currentSourceId = currentLocation.source.id;

    breakpointHit = breakpoints.filter(({ sourceId, line, node }) => {
      if (node !== undefined) {
        debug("node %d currentNode %d", node, currentNode);
        return sourceId === currentSourceId && node === currentNode;
      }
      //otherwise, we have a line-style breakpoint; we want to stop at the
      //*first* point on the line
      return sourceId === currentSourceId && line === currentLine && (currentSourceId !== previousSourceId || currentLine !== previousLine);
    }).length > 0;
  } while (!breakpointHit && !finished);
}

/**
 * reset -- reset the state of the debugger
 */
function* reset() {
  yield* data.reset();
  yield* evm.reset();
  yield* solidity.reset();
  yield* trace.reset();
}

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.inspectTransaction = inspectTransaction;
exports.obtainBinaries = obtainBinaries;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(4);

var _helpers = __webpack_require__(1);

var _actions = __webpack_require__(53);

var actions = _interopRequireWildcard(_actions);

var _actions2 = __webpack_require__(14);

var session = _interopRequireWildcard(_actions2);

var _adapter = __webpack_require__(54);

var _adapter2 = _interopRequireDefault(_adapter);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:ethersJS:sagas");

function* fetchTransactionInfo(adapter, { txHash }) {
  debug("inspecting transaction");
  var trace;
  try {
    trace = yield (0, _effects.apply)(adapter, adapter.getEthersTrace, [txHash]);
  } catch (e) {
    debug("putting error");
    yield (0, _effects.put)(actions.error(e));
    return;
  }

  debug("got trace");
  yield (0, _effects.put)(actions.receiveTrace(trace));

  let tx = yield (0, _effects.apply)(adapter, adapter.getEthersTransaction, [txHash]);

  let receipt = yield (0, _effects.apply)(adapter, adapter.getEthersReceipt, [txHash]);

  yield (0, _effects.put)(session.saveTransaction(tx));
  yield (0, _effects.put)(session.saveReceipt(receipt));

  if (tx.to && tx.to != "0x0" && tx.to != '0x0000000000000000000000000000000000000000') {
    yield (0, _effects.put)(actions.receiveCall({ address: tx.to, data: tx.data }));
    return;
  }
  if (receipt.contractAddress) {
    yield (0, _effects.put)(actions.receiveCall({ binary: tx.input || tx.data }));
    return;
  }

  throw new Error("Could not find contract associated with transaction. " + "Please make sure you're debugging a transaction that executes a " + "contract function or creates a new contract.");
}

function* fetchBinary(adapter, { address }) {
  debug("fetching binary for %s", address);
  let binary = yield (0, _effects.apply)(adapter, adapter.getEthersDeployedCode, [address]);

  debug("received binary for %s", address);
  yield (0, _effects.put)(actions.receiveBinary(address, binary));
}

function* inspectTransaction(txHash, provider) {
  yield (0, _effects.put)(actions.init(provider));
  yield (0, _effects.put)(actions.inspect(txHash));

  // let action = yield take(({ type }) =>
  //   type == actions.RECEIVE_TRACE || type == actions.ERROR_ETHERS_JS
  // );
  // debug("action %o", action);

  let action = yield (0, _effects.take)([actions.RECEIVE_TRACE, actions.ERROR_ETHERS_JS]);
  debug("action %o", action);

  var trace;
  if (action.type == actions.RECEIVE_TRACE) {
    trace = action.trace;
    debug("received trace");
  } else {
    return { error: action.error };
  }

  let { address, binary, data } = yield (0, _effects.take)(actions.RECEIVE_CALL);
  debug("received call");

  return { trace, address, binary, data };
}

function* obtainBinaries(addresses) {
  let tasks = yield (0, _effects.all)(addresses.map(address => (0, _effects.fork)(receiveBinary, address)));

  debug("requesting binaries");
  yield (0, _effects.all)(addresses.map(address => (0, _effects.put)(actions.fetchBinary(address))));

  let binaries = [];
  binaries = yield (0, _effects.all)(tasks.map(task => (0, _effects.join)(task)));

  debug("binaries %o", binaries);

  return binaries;
}

function* receiveBinary(address) {
  let { binary } = yield (0, _effects.take)(action => action.type == actions.RECEIVE_BINARY && action.address == address);
  debug("got binary for %s", address);

  return binary;
}

function* saga() {
  // wait for ethersjs init signal
  let { provider } = yield (0, _effects.take)(actions.INIT_ETHERS_JS);
  let adapter = new _adapter2.default(provider);

  yield (0, _effects.takeEvery)(actions.INSPECT, fetchTransactionInfo, adapter);
  yield (0, _effects.takeEvery)(actions.FETCH_BINARY, fetchBinary, adapter);
}

exports.default = (0, _helpers.prefixName)("ethersJS", saga);

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.init = init;
exports.inspect = inspect;
exports.fetchBinary = fetchBinary;
exports.receiveBinary = receiveBinary;
exports.receiveTrace = receiveTrace;
exports.receiveCall = receiveCall;
exports.error = error;
const INIT_ETHERS_JS = exports.INIT_ETHERS_JS = "INIT_ETHERS_JS";
function init(provider) {
  return {
    type: INIT_ETHERS_JS,
    provider
  };
}

const INSPECT = exports.INSPECT = "INSPECT_TRANSACTION";
function inspect(txHash) {
  return {
    type: INSPECT,
    txHash
  };
}

const FETCH_BINARY = exports.FETCH_BINARY = "FETCH_BINARY";
function fetchBinary(address) {
  return {
    type: FETCH_BINARY,
    address
  };
}

const RECEIVE_BINARY = exports.RECEIVE_BINARY = "RECEIVE_BINARY";
function receiveBinary(address, binary) {
  return {
    type: RECEIVE_BINARY,
    address,
    binary
  };
}

const RECEIVE_TRACE = exports.RECEIVE_TRACE = "RECEIVE_TRACE";
function receiveTrace(trace) {
  return {
    type: RECEIVE_TRACE,
    trace
  };
}

const RECEIVE_CALL = exports.RECEIVE_CALL = "RECEIVE_CALL";
function receiveCall({ address, binary, data }) {
  return {
    type: RECEIVE_CALL,
    address,
    binary,
    data
  };
}

const ERROR_ETHERS_JS = exports.ERROR_ETHERS_JS = "ERROR_ETHERS_JS";
function error(error) {
  return {
    type: ERROR_ETHERS_JS,
    error
  };
}

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _asyncToGenerator2 = __webpack_require__(13);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const ethers = __webpack_require__(55);

const debug = (0, _debug2.default)("debugger:ethersJS:adapter");

class EthersJSAdapter {
  constructor(provider) {
    this.ethersProvider = new ethers.providers.JsonRpcProvider(provider.connection);
  }

  getEthersTrace(txHash) {
    var _this = this;

    return (0, _asyncToGenerator3.default)(function* () {

      const result = yield _this.ethersProvider.send('debug_traceTransaction', [txHash, {}]);
      debug("result: %o", result);
      return result.structLogs;
    })();
  }

  getEthersTransaction(txHash) {
    var _this2 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      const result = yield _this2.ethersProvider.getTransaction(txHash);
      return result;
    })();
  }

  getEthersReceipt(txHash) {
    var _this3 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      const result = yield _this3.ethersProvider.getTransactionReceipt(txHash);
      return result;
    })();
  }

  /**
   * getDeployedCode - get the deployed code for an address from the client
   * @param  {String} address
   * @return {String}         deployedBinary
   */

  getEthersDeployedCode(address) {
    var _this4 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      debug("getting deployed code for %s", address);
      const result = yield _this4.ethersProvider.getCode(address);
      debug("got deployed code for %s", address);
      return result;
    })();
  }
}
exports.default = EthersJSAdapter;

/***/ }),
/* 55 */
/***/ (function(module, exports) {

module.exports = require("ethers");

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ERROR = exports.ACTIVE = exports.WAITING = undefined;
exports.status = status;
exports.transaction = transaction;
exports.receipt = receipt;

var _redux = __webpack_require__(6);

var _reducers = __webpack_require__(57);

var _reducers2 = _interopRequireDefault(_reducers);

var _reducers3 = __webpack_require__(58);

var _reducers4 = _interopRequireDefault(_reducers3);

var _reducers5 = __webpack_require__(60);

var _reducers6 = _interopRequireDefault(_reducers5);

var _reducers7 = __webpack_require__(61);

var _reducers8 = _interopRequireDefault(_reducers7);

var _reducers9 = __webpack_require__(62);

var _reducers10 = _interopRequireDefault(_reducers9);

var _actions = __webpack_require__(14);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const WAITING = exports.WAITING = "WAITING";
const ACTIVE = exports.ACTIVE = "ACTIVE";
const ERROR = exports.ERROR = "ERROR";

function status(state = WAITING, action) {
  switch (action.type) {
    case actions.READY:
      return ACTIVE;

    case actions.ERROR:
      return { error: action.error };

    default:
      return state;
  }
}

function transaction(state = {}, action) {
  switch (action.type) {
    case actions.SAVE_TRANSACTION:
      return action.transaction;
    default:
      return state;
  }
}

function receipt(state = {}, action) {
  switch (action.type) {
    case actions.SAVE_RECEIPT:
      return action.receipt;
    default:
      return state;
  }
}

const session = (0, _redux.combineReducers)({
  status,
  transaction,
  receipt
});

const reduceState = (0, _redux.combineReducers)({
  session,
  data: _reducers2.default,
  evm: _reducers4.default,
  solidity: _reducers6.default,
  trace: _reducers8.default,
  controller: _reducers10.default
});

exports.default = reduceState;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = __webpack_require__(5);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(8);

var _assign2 = _interopRequireDefault(_assign);

var _set = __webpack_require__(18);

var _set2 = _interopRequireDefault(_set);

var _values = __webpack_require__(19);

var _values2 = _interopRequireDefault(_values);

var _extends2 = __webpack_require__(7);

var _extends3 = _interopRequireDefault(_extends2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _redux = __webpack_require__(6);

var _helpers = __webpack_require__(1);

var _actions = __webpack_require__(28);

var actions = _interopRequireWildcard(_actions);

var _truffleDecoder = __webpack_require__(24);

var _truffleDecodeUtils = __webpack_require__(3);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:data:reducers");

const DEFAULT_SCOPES = {
  byId: {}
};

function scopes(state = DEFAULT_SCOPES, action) {
  var scope;
  var variables;

  switch (action.type) {
    case actions.SCOPE:
      scope = state.byId[action.id] || {};

      return {
        byId: (0, _extends3.default)({}, state.byId, {

          [action.id]: (0, _extends3.default)({}, scope, {

            id: action.id,
            sourceId: action.sourceId,
            parentId: action.parentId,
            pointer: action.pointer
          })
        })
      };

    case actions.DECLARE:
      scope = state.byId[action.node.scope] || {};
      variables = scope.variables || [];

      return {
        byId: (0, _extends3.default)({}, state.byId, {

          [action.node.scope]: (0, _extends3.default)({}, scope, {

            variables: [...variables, { name: action.node.name, id: action.node.id }]
          })
        })
      };

    default:
      return state;
  }
}

//a note on the following reducer: solidity assigns a unique AST ID to every
//AST node among all the files being compiled together.  thus, it is, for now,
//safe to identify user-defined types solely by their AST ID.  In the future,
//once we eventually support having some files compiled separately from others,
//this will become a bug you'll have to fix, and you'll have to fix it in the
//decoder, too.  Sorry, future me! (or whoever's stuck doing this)

function userDefinedTypes(state = [], action) {
  switch (action.type) {
    case actions.DEFINE_TYPE:
      return [...state, action.node.id];
    default:
      return state;
  }
}

const DEFAULT_ALLOCATIONS = {
  storage: {},
  memory: {},
  calldata: {}
};

function allocations(state = DEFAULT_ALLOCATIONS, action) {
  if (action.type === actions.ALLOCATE) {
    return {
      storage: action.storage,
      memory: action.memory,
      calldata: action.calldata
    };
  } else {
    return state;
  }
}

const info = (0, _redux.combineReducers)({
  scopes,
  userDefinedTypes,
  allocations
});

const DEFAULT_ASSIGNMENTS = {
  byId: {},
  byAstId: {}
};

function assignments(state = DEFAULT_ASSIGNMENTS, action) {
  switch (action.type) {
    case actions.ASSIGN:
    case actions.MAP_PATH_AND_ASSIGN:
      debug("action.type %O", action.type);
      debug("action.assignments %O", action.assignments);
      return (0, _values2.default)(action.assignments.byId).reduce((acc, assignment) => {
        let { id, astId } = assignment; //we don't need the rest
        return {
          byId: (0, _extends3.default)({}, acc.byId, {
            [id]: assignment
          }),
          byAstId: (0, _extends3.default)({}, acc.byAstId, {
            [astId]: [...new _set2.default([...(acc.byAstId[astId] || []), id])]
            //we use a set for uniqueness
          })
        };
      }, state);

    case actions.LEARN_ADDRESS:
      let { dummyAddress, address } = action;
      return {
        byId: (0, _assign2.default)({}, ...(0, _values2.default)(state.byId).map(assignment => {
          let newAssignment = learnAddress(assignment, dummyAddress, address);
          return {
            [newAssignment.id]: newAssignment
          };
        })),
        byAstId: (0, _assign2.default)({}, ...(0, _entries2.default)(state.byAstId).map(([astId]) => {
          return {
            [astId]: state.byAstId[astId].map(id => learnAddress(state.byId[id], dummyAddress, address).id
            //this above involves some recomputation but oh well
            )
          };
        }))
      };

    case actions.RESET:
      return DEFAULT_ASSIGNMENTS;

    default:
      return state;
  }
}

function learnAddress(assignment, dummyAddress, address) {
  if (assignment.dummyAddress === dummyAddress) {
    //we can assume here that the object being
    //transformed has a very particular form
    let newIdObj = {
      astId: assignment.astId,
      address
    };
    let newId = (0, _helpers.stableKeccak256)(newIdObj);
    return {
      id: newId,
      ref: assignment.ref,
      astId: assignment.astId,
      address
    };
  } else {
    return assignment;
  }
}

const DEFAULT_PATHS = {
  decodingStarted: 0,
  byAddress: {}
};

//WARNING: do *not* rely on mappedPaths to keep track of paths that do not
//involve mapping keys!  Yes, many will get mapped, but there is no guarantee.
//Only when mapping keys are involved does it necessarily work reliably --
//which is fine, as that's all we need it for.
function mappedPaths(state = DEFAULT_PATHS, action) {
  switch (action.type) {
    case actions.MAP_KEY_DECODING:
      debug("decoding started: %d", state.decodingStarted + (action.started ? 1 : -1));
      return (0, _extends3.default)({}, state, {
        decodingStarted: state.decodingStarted + (action.started ? 1 : -1)
      });
    case actions.MAP_PATH_AND_ASSIGN:
      let { address, slot, typeIdentifier, parentType } = action;
      //how this case works: first, we find the spot in our table (based on
      //address, type identifier, and slot address) where the new entry should
      //be added; if needed we set up all the objects needed along the way.  If
      //there's already something there, we do nothing.  If there's nothing
      //there, we record our given slot in that spot in that table -- however,
      //we alter it in one key way.  Before entry, we check if the slot's
      //*parent* has a spot in the table, based on address (same for both child
      //and parent), parentType, and the parent's slot address (which can be
      //found as the slotAddress of the slot's path object, if it exists -- if
      //it doesn't then we conclude that no the parent does not have a spot in
      //the table).  If the parent has a slot in the table already, then we
      //alter the child slot by replacing its path with the parent slot.  This
      //will keep the slotAddress the same, but since the versions kept in the
      //table here are supposed to preserve path information, we'll be
      //replacing a fairly bare-bones Slot object with one with a full path.

      //we do NOT want to distinguish between types with and without "_ptr" on
      //the end here!
      debug("typeIdentifier %s", typeIdentifier);
      typeIdentifier = _truffleDecodeUtils.Definition.restorePtr(typeIdentifier);
      parentType = _truffleDecodeUtils.Definition.restorePtr(parentType);

      debug("slot %o", slot);
      let hexSlotAddress = _truffleDecodeUtils.Conversion.toHexString((0, _truffleDecoder.slotAddress)(slot), _truffleDecodeUtils.EVM.WORD_SIZE);
      let parentAddress = slot.path ? _truffleDecodeUtils.Conversion.toHexString((0, _truffleDecoder.slotAddress)(slot.path), _truffleDecodeUtils.EVM.WORD_SIZE) : undefined;

      //this is going to be messy and procedural, sorry.  but let's start with
      //the easy stuff: create the new address if needed, clone if not
      let newState = (0, _extends3.default)({}, state, {
        byAddress: (0, _extends3.default)({}, state.byAddress, {
          [address]: {
            byType: (0, _extends3.default)({}, (state.byAddress[address] || { byType: {} }).byType)
          }
        })
      });

      //now, let's add in the new type, if needed
      newState.byAddress[address].byType = (0, _extends3.default)({}, newState.byAddress[address].byType, {
        [typeIdentifier]: {
          bySlotAddress: (0, _extends3.default)({}, (newState.byAddress[address].byType[typeIdentifier] || {
            bySlotAddress: {}
          }).bySlotAddress)
        }
      });

      let oldSlot = newState.byAddress[address].byType[typeIdentifier].bySlotAddress[hexSlotAddress];
      //yes, this looks strange, but we haven't changed it yet except to
      //clone or create empty (and we don't want undefined!)
      //now: is there something already there or no?  if no, we must add
      if (oldSlot === undefined) {
        let newSlot;
        debug("parentAddress %o", parentAddress);
        if (parentAddress !== undefined && newState.byAddress[address].byType[parentType] && newState.byAddress[address].byType[parentType].bySlotAddress[parentAddress]) {
          //if the parent is already present, use that instead of the given
          //parent!
          newSlot = (0, _extends3.default)({}, slot, {
            path: newState.byAddress[address].byType[parentType].bySlotAddress[parentAddress]
          });
        } else {
          newSlot = slot;
        }
        newState.byAddress[address].byType[typeIdentifier].bySlotAddress[hexSlotAddress] = newSlot;
      }
      //if there's already something there, we don't need to do anything

      return newState;

    case actions.RESET:
      return DEFAULT_PATHS;

    case actions.LEARN_ADDRESS:
      debug("action %o", action);
      return (0, _extends3.default)({}, state, {
        byAddress: (0, _assign2.default)({}, ...(0, _entries2.default)(state.byAddress).map(([address, types]) => ({
          [address == action.dummyAddress ? action.address : address]: types
          //using == due to string/number discrepancy
        })))
      });

    default:
      return state;
  }
}

const proc = (0, _redux.combineReducers)({
  assignments,
  mappedPaths
});

const reducer = (0, _redux.combineReducers)({
  info,
  proc
});

exports.default = reducer;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = __webpack_require__(18);

var _set2 = _interopRequireDefault(_set);

var _from = __webpack_require__(59);

var _from2 = _interopRequireDefault(_from);

var _extends2 = __webpack_require__(7);

var _extends3 = _interopRequireDefault(_extends2);

exports.callstack = callstack;

var _redux = __webpack_require__(6);

var _actions = __webpack_require__(30);

var actions = _interopRequireWildcard(_actions);

var _helpers = __webpack_require__(1);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DEFAULT_CONTEXTS = {
  byContext: {},
  byBinary: {}
};

function contexts(state = DEFAULT_CONTEXTS, action) {
  switch (action.type) {
    /*
     * Adding a new context
     */
    case actions.ADD_CONTEXT:
      {
        const { contractName, raw, compiler } = action;
        const context = (0, _helpers.keccak256)(raw);

        return (0, _extends3.default)({}, state, {

          byContext: (0, _extends3.default)({}, state.byContext, {

            [context]: (0, _extends3.default)({}, state.byContext[context] || {}, {

              contractName,
              context,
              compiler
            })
          })
        });
      }

    /*
     * Adding binary for a context
     */
    case actions.ADD_BINARY:
      {
        const { context, binary } = action;

        if (state.byBinary[binary]) {
          return state;
        }

        return {
          byContext: (0, _extends3.default)({}, state.byContext, {

            [context]: (0, _extends3.default)({}, state.byContext[context], {

              binary
            })
          }),

          byBinary: (0, _extends3.default)({}, state.byBinary, {

            [binary]: { context: context }
          })
        };
      }

    /*
     * Default case
     */
    default:
      return state;
  }
}

const DEFAULT_INSTANCES = {
  byAddress: {},
  byContext: {}
};

function instances(state = DEFAULT_INSTANCES, action) {
  switch (action.type) {
    /*
     * Adding a new address for context
     */
    case actions.ADD_INSTANCE:
      let { address, context, binary } = action;

      // get known addresses for this context
      let otherInstances = state.byContext[context] || [];
      let otherAddresses = otherInstances.map(({ address }) => address);

      return {
        byAddress: (0, _extends3.default)({}, state.byAddress, {

          [address]: { address, context, binary }
        }),

        byContext: (0, _extends3.default)({}, state.byContext, {

          // reconstruct context instances to include new address
          [context]: (0, _from2.default)(new _set2.default(otherAddresses).add(address)).map(address => ({ address }))
        })
      };

    /*
     * Default case
     */
    default:
      return state;
  }
}

const info = (0, _redux.combineReducers)({
  contexts,
  instances
});

function callstack(state = [], action) {
  switch (action.type) {
    case actions.CALL:
      const { address, data } = action;
      return state.concat([{ address, data }]);

    case actions.CREATE:
      const binary = action.binary;
      return state.concat([{ binary, data: "0x" }]);
    //note: the empty data for creation calls doesn't matter right now, but
    //it will once I implement globally available variables

    case actions.RETURN:
      //HACK: pop the stack, UNLESS that would leave it empty (this will only
      //happen at the end when we want to keep the last one around)
      return state.length > 1 ? state.slice(0, -1) : state;

    case actions.RESET:
      return [state[0]]; //leave the initial call still on the stack

    default:
      return state;
  }
}

const proc = (0, _redux.combineReducers)({
  callstack
});

const reducer = (0, _redux.combineReducers)({
  info,
  proc
});

exports.default = reducer;

/***/ }),
/* 59 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/array/from");

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(7);

var _extends3 = _interopRequireDefault(_extends2);

var _keys = __webpack_require__(23);

var _keys2 = _interopRequireDefault(_keys);

exports.functionDepth = functionDepth;

var _redux = __webpack_require__(6);

var _helpers = __webpack_require__(1);

var _actions = __webpack_require__(32);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DEFAULT_SOURCES = {
  byId: {}
};

function sources(state = DEFAULT_SOURCES, action) {
  switch (action.type) {
    /*
     * Adding a new source
     */
    case actions.ADD_SOURCE:
      let { ast, source, sourcePath, compiler } = action;

      let id = (0, _keys2.default)(state.byId).length;

      return {
        byId: (0, _extends3.default)({}, state.byId, {

          [id]: {
            id,
            ast,
            source,
            sourcePath,
            compiler
          }
        })
      };

    /*
     * Default case
     */
    default:
      return state;
  }
}

const DEFAULT_SOURCEMAPS = {
  byContext: {}
};

function sourceMaps(state = DEFAULT_SOURCEMAPS, action) {
  switch (action.type) {
    /*
     * Adding a new sourceMap
     */
    case actions.ADD_SOURCEMAP:
      let { binary, sourceMap } = action;
      let context = (0, _helpers.keccak256)(binary);

      return {
        byContext: (0, _extends3.default)({}, state.byContext, {

          [context]: {
            context,
            sourceMap
          }
        })
      };

    /*
     * Default Case
     */
    default:
      return state;
  }
}

const info = (0, _redux.combineReducers)({
  sources,
  sourceMaps
});

function functionDepth(state = 0, action) {
  switch (action.type) {
    case actions.JUMP:
      const delta = spelunk(action.jumpDirection);
      return state + delta;

    case actions.RESET:
      return 0;

    default:
      return state;
  }
}

function spelunk(jump) {
  if (jump === "i") {
    return 1;
  } else if (jump === "o") {
    return -1;
  } else if (jump === "2") {
    return 2; //HACK WORKAROUND
  } else {
    return 0;
  }
}

const proc = (0, _redux.combineReducers)({
  functionDepth
});

const reducer = (0, _redux.combineReducers)({
  info,
  proc
});

exports.default = reducer;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.index = index;
exports.finished = finished;
exports.steps = steps;

var _redux = __webpack_require__(6);

var _actions = __webpack_require__(11);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function index(state = 0, action) {
  switch (action.type) {
    case actions.TOCK:
      return state + 1;

    case actions.RESET:
      return 0;

    default:
      return state;
  }
}

function finished(state = false, action) {
  switch (action.type) {
    case actions.END_OF_TRACE:
      return true;

    case actions.RESET:
      return false;

    default:
      return state;
  }
}

function steps(state = null, action) {
  if (action.type === actions.SAVE_STEPS) {
    return action.steps;
  } else {
    return state;
  }
}

const info = (0, _redux.combineReducers)({
  steps
});

const proc = (0, _redux.combineReducers)({
  index,
  finished
});

const reducer = (0, _redux.combineReducers)({
  info,
  proc
});

exports.default = reducer;

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _redux = __webpack_require__(6);

var _actions = __webpack_require__(20);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:controller:reducers"); //eslint-disable-line no-unused-vars

function breakpoints(state = [], action) {
  switch (action.type) {
    case actions.ADD_BREAKPOINT:
      //check for any existing identical breakpoints to avoid redundancy
      if (state.filter(breakpoint => breakpoint.sourceId === action.breakpoint.sourceId && breakpoint.line === action.breakpoint.line && breakpoint.node === action.breakpoint.node //may be undefined
      ).length > 0) {
        //if it's already there, do nothing
        return state;
      } else {
        //otherwise add it
        return state.concat([action.breakpoint]);
      }
      break;

    case actions.REMOVE_BREAKPOINT:
      return state.filter(breakpoint => breakpoint.sourceId !== action.breakpoint.sourceId || breakpoint.line !== action.breakpoint.line || breakpoint.node !== action.breakpoint.node //may be undefined
      );
      break;

    case actions.REMOVE_ALL_BREAKPOINTS:
      return [];

    default:
      return state;
  }
}

const CONTROL_ACTIONS = [actions.ADVANCE, actions.STEP_NEXT, actions.STEP_OVER, actions.STEP_INTO, actions.STEP_OUT, actions.CONTINUE, actions.RESET];

function isStepping(state = false, action) {
  if (CONTROL_ACTIONS.includes(action.type)) {
    debug("got step start action");
    return true;
  } else if (action.type === actions.DONE_STEPPING) {
    debug("got step stop action");
    return false;
  } else {
    return state;
  }
}

const reducer = (0, _redux.combineReducers)({
  breakpoints,
  isStepping
});

exports.default = reducer;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = __webpack_require__(5);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(8);

var _assign2 = _interopRequireDefault(_assign);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(2);

var _selectors = __webpack_require__(10);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(9);

var _selectors4 = _interopRequireDefault(_selectors3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:session:selectors");

const session = (0, _reselectTree.createSelectorTree)({
  /**
   * session.info
   */
  info: {

    /**
     * session.info.affectedInstances
     */
    affectedInstances: (0, _reselectTree.createLeaf)([_selectors2.default.info.instances, _selectors2.default.info.contexts, _selectors4.default.info.sources, _selectors4.default.info.sourceMaps], (instances, contexts, sources, sourceMaps) => (0, _assign2.default)({}, ...(0, _entries2.default)(instances).map(([address, { context }]) => {
      debug("instances %O", instances);
      debug("contexts %O", contexts);
      let { contractName, binary } = contexts[context];
      let { sourceMap } = sourceMaps[context] || {};

      let { source } = sourceMap ?
      // look for source ID between second and third colons (HACK)
      sources[sourceMap.match(/^[^:]+:[^:]+:([^:]+):/)[1]] : {};

      return {
        [address]: {
          contractName, source, binary
        }
      };
    })))

  },

  /**
   * session.transaction (namespace)
   */
  transaction: {

    /**
     * session.transaction (selector)
     * contains the ethers transaction object
     */
    _: state => state.session.transaction,

    /**
     * session.transaction.receipt
     * contains the ethers receipt object
     */
    receipt: state => state.session.receipt

  }

});

exports.default = session;

/***/ })
/******/ ]);
});